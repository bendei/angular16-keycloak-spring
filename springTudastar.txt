kell még: spring jwt rest authentication, JPA spring boottal


## Spring Boot Rest Service:

1.	Make sure, you maven dependency section has spring-boot-starter-web dependency.
2.	starting point Application.java has the friendly public static void main method. Where we actually start a Spring Boot Application:
	running the Application.java like any other Java class and see the server being up and listening for port 8080 (configurable).

	@SpringBootApplication: viele Entwickler annotieren main class mit @Configuration, @EnableAutoConfiguration and @ComponentScan.
	Spring Boot provides a convenient @SpringBootApplication alternative.
	Dises Annotation hat folgende Properties: exclude = exclude lis of classes; scanBasePackage = list  of packages for ComponentScan.
		@ComponentScan: gtells Spring to look for other components, configurations, and services in the specified package. Spring is able to auto scan, detect and register your beans
			or components from pre-defined project package. If no package is specified current class package is taken as the root package.
		@Configuration: annotation indicates that the class is a source of bean definitions. We can also add it to multiple configuration classe
		@EnableAutoConfiguration: If HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring will auto-configure an in-memory database.

https://okt.sed.hu/spring_uzleti/eloadas/02_ioc/

	DI:  DI esetében az úgynevezett IoC konténer injektálja be a függőséget a függő komponensbe.
		constructor: der Consumer deklariert seine Abhängigkeit in seinem Konstruktor Methode als Parameter. DI container injiziert es automatisch bem Instanzieren des Beans,
					d.h. es muss schon vor dem Instanzieren zur Verfügung stehen.
		Setter und  based dependency injection: Abhängigkeit wird durch ein Setter Methode injiziert, soll nicht unbedingt beim Consumer-Instanzierung existieren, plus
					es kann im Laufe auch ausgetauscht werden.

		Bean Definitionen in xml config Datei
		Zentrales Komponent: BeanFactory, es verwaltet die Komponente (=beans) und ihre Lebenscyklen in dem Container.
		Im einfachsten Fall: wir definieren ein Hund Schnittstelle, und ein HundImpl Klasse die diese Schnittstelle implenentiert. bean-definitions.xml wo wir die bean registrieren:
			 <bean id="hund" name="wiseworm" class="HundImpl"/>
			  DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); // egy BeanFactrory megvalósítás
              XmlBeanDefinitionReader rdr = new XmlBeanDefinitionReader(factory);  // bean definíciók beolvasása fájlból
			  Hund hund = beanFactory.getBean("hund"); 	// so erhalten wir ein

		BeanFactory schnittstelle unterstüzt die Annotation-based bean Konfiguration nicht ->
			AplicationContext: unterstüzt es, plus, Transaktionsmanagement, Mehrsprachigkeit etc.

		Bean Definitionen mit Anntoationen: @Bean
		Stereotype Annotationen: @Component/Service/Repository/Controller/Configuration, sie werden je nach Rolle verwendet in der Bean Klasse.
		Anstatt einem beans-definition.xml Implementieren wir eine Klasse, wo wir die bean Definitionen mit Annotationen angeben:
			@Configuration
			public class HelloWorldConfiguration {

				@Bean	// signalisiert daß diese Methode ein Instanz bean zurückliefert
				public MessageProvider provider() {
					return new HelloWorldMessageProvider();
				}

	Bean zu bekommen vom Container:

		ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfiguration.class);
			MessageRenderer mr = ctx.getBean("provider", MessageProvider.class);

		Wenn wir die Bean-Klasse mit den stereotype Annotationen regitrieren, dann brauchen wird es mit dem @Bean in der @COnfiguration Klasse nicht mehr zu tun.
			Dabei sollen wir aber @ComponentScan(basePackages = {"com.suaf"}) angeben, damit der DI weiß wo es nach bean suchen soll.

		Verwendung ein bean in einem anderem:

			@Service("renderer")
			public class StandardOutMessageRenderer implements MessageRenderer {
				private MessageProvider messageProvider;
				...
				@Autowired	// damit Spring die bean anhand @ComponentScan (verwendet in der Configuration Klasse) findet und mit setter injiziert.
				public void setMessageProvider(MessageProvider provider) {
					this.messageProvider = provider;
				}
			}

			mit Konstruktor:
				private MyDao mydao;

			//we can use autowiring on properties, setters, and constructors.:
https://www.baeldung.com/spring-autowire
			  @Autowired
			  public ConfigurableMessageProvider(MyDAO mydao) {
				this.mydao = mydao;
			 }

	Bean haben scopes: @Scope("singleton")
		- singleton
		- prototype: für jede Anfrage wird eine neue Instanz erstellt.
		- web fähiges Scopes: request: Instanz für jede Http Request
							  session für jede Session
							  application: für jede ServletContext

########################################################################################################################################################################

REST:

GET:
	As we indicated above, using content negotiation, the client can be proactive about what is requested as long as the server supports it.
	One of the key points about the GET request is that it should not modify anything on the server side. It is fundamentally a safe
	request.
	http://example.com/res/action=update?data=1234  Do not do this! GET requests are also intended to be idempotent. This means
	that issuing a request more than once will have no consequences.
		1. Server return 200
		2. if not found: return 404
POST:
	for creating a new resource
	place orders, submit forms, etc., we cannot predict how the server will name these resources we are creating. This is why we POST a
	representation of the resource to a handler (e.g. servlet). The server will accept the input, validate it, verify the user’s credentials, etc.

	Upon successful processing, the server will return a 201 HTTP response code with a “Location” header indicating the location of
	the newly created resource.

	Another major use of the POST verb is to “append” a resource. This is an incremental edit or a partial update, not a full resource
	submission. For that, use the PUT operation. A POST update to a known resource would be used for something like adding a new
	shipping address to an order or updating the quantity of an item in a cart.

	- The API need not return the created resource in the Response Stream.
	- It should return an empty response body.
	- Instead the API must return a HTTP Status 201 indicating the resource was created.
	- Also in the location header of the response it must return a URL needed to access the newly created resource. The client can if it needs fetch the new resource
	  by making a GET call to the returned URL.

	A final common use of POST is to submit queries

	Részletesen:
	https://stackoverflow.com/questions/1860645/create-request-with-post-which-response-codes-200-or-201-and-content
PUT:
	updateing the resource, but the whole entity. If there are certain entity propertiesprovided by the put request than they
	should be set to null on the entity.
PATCH:
	updateing the resource, partially updating the resource. So the patch doest not represents the whole resource (entity object).
	Only attributes that are present must be updated, the others shoud remain unchanged(unlike by put where they et set to null).
	It could also send a list of modifications. Each modification can be a dict specifying the JSON path of the node to modify, the modification (‘add’, ‘remove’, ‘change’) and the new value.
DELETE:
	server rsponses with 204(no content) or with 404 if the resource was not found.
HEAD:
	The HEAD verb is used to issue a request for a resource without actually retrieving it. It is a way for a client to check for the
	existence of a resource and possibly discover metadata about it.
OPTIONS:
	The OPTIONS verb is also used to interrogate a server about a resource b

	Response codes:
	restfularchitecure.pdf ben


HttpEntity represents an HTTP request or response consists of headers and body. // Only talks about body & headers, but doesn't talk about status code
public HttpEntity(T body, MultiValueMap<String,String> headers)

ResponseEntity extends HttpEntity but also adds a Http status code.

// i.e ResponseEntity = HttpEntity + StatusCode
public ResponseEntity(T body, MultiValueMap<String,String> headers, HttpStatus statusCode)

########################################################################################################################################################################
EXCEPTION HANDLING:
########################################################################################################################################################################

https://springframework.guru/exception-handling-in-spring-boot-rest-api/

Wir implementieren custom Exceptions für jede typsche Business Exceptionen, zB BookNotFoundException, BookAlreadyExistException (extending RuntimeException).
Beim Abfangen diese werden responses zu den Angular client zurückgeschickt:

@ControllerAdvice Klasse mit @ExceptionHandler methoden -> returns ResponseEntity
Wir verwendeten ein globales Exception Handler Klasse, die alle in den RestController/Service/Repository auftretetnde Exceptionen abfängt und behandelt.
Zb: beim GET wird ein book id angegeben wofür die Repository keinen Eintrag i  dem DB findet und so wirft ein custom ResourceNotFoundException Ausnahme zurück zum Controller.
Hier tritt der globaler Exceptionhandler ein, es ist ein spring AOP @ControllerAdvice annotierte Klasse. Für jede Exceptiontypen implementieren wir eine HandlerMethode
mit @ExceptionHandler Annotation. Der ExceptionHandler gibt ein ResponseEntity<error, status> , zurück.

	@ExceptionHandler(value = ResourceNotFoundException.class)
	public ResponseEntity<ExceptionResponse> handleNotCreated(ResourceNotFoundException e) {
		ExceptionResponse resp = new ExceptionResponse();
		resp.setErrorCode("56565: internal restone app error code.");
		resp.setMsg(e.getMessage());
		resp.setResourceId(e.getResourceId());
		resp.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.toString());
		resp.setOriginalMsg(e.getOriginalMsg());
		resp.setExcTime(LocalDateTime.now());
		return new ResponseEntity<ExceptionResponse>(resp, HttpStatus.INTERNAL_SERVER_ERROR);
	}
Repository specko exceptionokat dob, amiket a GlobalExceptionHandler ben kezelünk le.
a rrepository dobhat EntityNotFoundException- de azt try cahctel a serviceImpl ben nem tudjuk elkapni, mert egy az egy szinttel lejjeb van -> GlobalExceptionHandler ben kezeljük le.

Van olyan repo metódus amelyik nem dob exception, hanem Optionalt ad vissza és azt csekkeljük le hogy empty(), ha az akkor mi dobunk egy custom exceptiont a glolbalhandlernek
########################################################################################################################################################################
Repository interface -ről:
https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories

Persistence: Spring Data JPA ( ez a Repository interfészes cucc)
https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories
	Spring Boot Hibernate JPA

spring-boot-starter-data-jpa ist nötig im pom Datei.
Spring Boot configures Hibernate as the default JPA provider, so it's no longer necessary to define the entityManagerFactory bean unless we want to customize it.

az embedded h2 databaset használom most tanulásra:
https://www.baeldung.com/spring-boot-h2-database
http://localhost:8080/h2-console

Szupi leirás hogy mit és hogyan lehet konfigurálni egészen a hibernate-logginig
https://thorben-janssen.com/configuring-spring-data-jpa-with-spring-boot/

********************************************************************************************************************************************
JPA / Hibernate
********************************************************************************************************************************************
Da spring boot ist mit spring data jpa integriert ist, so es liefert eine Menge default Konfigurationen und addiert automatisch Abhaengigkeiten zu meinem Projekt,
also spring-boot starter fügt alle nötigen und common Abhaengigkeiten zu dem Projekt und konfiguriert diese zugleich. Das einzige dass konfiguriert soll
ist das connection information:

( ohne bot: wir sollten EntityManager, DataSource und Transactionmanager explizit definieren)

	-	Addiert by defaultHikariCP connection pool und konfiguriert es zuglecih. Es kann aber im applicatio.properties file konfiguriert werden.
	-	In memory DB H2
	-	verwendet Hibernate als default JPA Provider und konfiguriert EntityManagerFactory.
	-	verwendet und konfiguriert embedded Transaction Manager Atomikos
	-	Konfiguration um Data JPA Repositiores verwenden zu können.

	Beim external DB  wir müssen bloß volgendes im application.properties angeben:
		spring.datasource.url=jdbc:postgresql://localhost:5432/test
		spring.datasource.username=postgres
		spring.datasource.password=postgres

	Konfigurieren explicit das connection pool:
		spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSource

Entity manager speichert, holt zurück, aktualisiert, löscht entities from the DB. Es representiert ein DB connection und ist mit Persistent context zugeordnet,
Entities und ihre Lebenszyklus sind innerhalbe PC verwaltet. Durch ein EM kann man mehrere Query / Criteria erstellen, zu jeder EM gehört ein EntityTransaction
(wird durch EM erzeugt).

   Entity manager kann auf 2 Weise erzeugt und verwendet werden:
	-	container managed EM: beim Spring app wird ein EM direkt von spring container erzeugt und verwaltet durch DI.
		Dabei sollte man im DAO Klasse die EM mit @PersistentContext annotieren und in das DAO injizieren:

			@PersistenceContext
			EntityManager entityManager;

			@Override
			public Optional<ServiceCredentialEntity> findById(String serviceId) {
				ServiceCredentialEntity entity = entityManager.find(ServiceCredentialEntity.class, serviceId);
				if (entity != null) {
					return Optional.of(entity);
				}
				return null;
			}

	-	application managed EM: in disem Fall verwenden wir EntityManagerFactory API um ein factory und dann dadurch ein EM zu erzuegen.

	Lebenszeklus Zustände des Entity:
	Persistent Context verfolgt und verwaltet die Zustände des entity, deketiert eine Anderung dann speichert es automatisch.
		- Transient: object erst erzeugt, PC kennt aber es nicht so macht es keinen insert / update wenn es deketiert eine änderung.
					Hat kein PK und record im DB.
					(mit find() wird es entity in Kenntnis nehmen, und in managed state versetzen.)
		- Managed: alle Objkete die mit PC verbunden sind, sind in diesem Zustand. d.h. Hibernate will insert/update wenn es eine Anderung detektiert wenn
					es das context flushes.
					um ein Entity managed zu machen:
													-	persist()
													-	find()
													-	merge/update

		- Detached: früher managed, aber jetzt PC ist geschlossen, transaction closed. Mit EntityManager.merge() kann es wieder attached.

		- Deleted: EM.remove() -> wird nicht gleich vom DB entfernt, sondern nur nachh dem flush()

List kann Duplicates haben und ist ordered, wogegen Set kann keine Duplikate haben und ist nicht ordered.
Set : kann keine Duplikate enthalten ( equals()).

SQL tipusai:
DDL: data defintion language: creating, modifying table
DML: insert, update , delete -> iró műveletek
DQL: select -> olvasó műveletek
DCL: jogositvány kezelő rendser-> set grant
------------
Foreign Key: az egyik táblában az adott mező értéke egy masik tábla adott mezőjének értékét veszi fel, és nem lehet Null azaz léteznie kell a másikban. Használjuk a table relationshipek leirására.
REFERENCE INTEGRITY: foreign key-> points to PK ( léteznie kell a foreign key értékének mint PK a másik táblában)

 many-many: kapcsolo tábla , két FK val., pl diák-tantrgy ( tartalmazuhat csak két foreign keyt, de néha plusz infot is mint pédálul érdemjegy)

referencia integritas -> cascade deleting (ha egy tábla PK ja egy másik tábla idegen kulcsa akkor ha a PK törölni akarom de mutat rá egy sor -> ReferenceIntegrityException
a tulajdonos.szamla hivatkozik a bankszamlak.szamla_szam ra (ami egy foreign key a tulajdonos.számla mezőhöz)
 )
------------
RESTRICT: addig nem törölhetekegy rekordot amig van hivatkozás a rekordra
CASCADE: ha törlök egy rekordot akkor az összes hivatkozo rekordot is törölnöm kell, ugy biztonságos hogy nem engedjük a cascade törlést, hanem előbb
		törölni kell az összes hivatkozo rekordot és utána engegi az érintett rekord törlését
------------
N+1
(https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping)
N + 1 query problem: mikor van egy item  rekordunk es ahhoz egy related tablában egy category rekord: ha le akarjuk lkérdezni a item-categorikat is:
    1. egy query hogy visszakapjuk az itemek listáját, majd végig iterálva a listák elemein egyenként querit inditunk a categoryk lekérdezéséhez is: Lassú mert 1+20 lekérdezést indítunk el.
    2. Egyetlen nagyobb lekérdezést inditunk join-nal.

    In JPA/Hibernate beim JPQL / Criteria:
        Wir habe Post -> (many) Postícomments
            @Entity()
                public class PostComment {
                    @ManyToOne
                    private Post post;
                }

            Scenarios:
             1:      @ManyToOne(fetch = fetchType.LAZY)
                     private Post post;
                     Erst wird keine Post auds dem DB geholt, nur eine Query für die PostComments. Aber wenn wir nachher die Post Assoziationen referien in dem Kode, dann wird 1+N Queries ausgeführt.
                        for(PostComment comment : comments) {
                            LOGGER.info(
                                "The Post '{}' got this review '{}'",
                                comment.getPost().getTitle(),
                                comment.getReview()
                            );
                        }
             2.  @ManyToOne(fetch = fetchType.EAGER): Problem: wir können weit mehr Data holen, als wird eigentlich brauchen. Zweitens: wird für alle Post Entites ein separater Query ausgeführt.
             3.  @ManyToOne(fetch = fetchType.JOIN_FETCH): wird ein einziger Query mit join ausgeführt.

NAGYON JO: join vs join fetch:    https://dzone.com/articles/how-to-decide-between-join-and-join-fetch

------------
DUMP: mikor nem szabad a eredeti db-t használni, hanem egy szöveges fájlban megkapom a db-t, importálom: ez a dumpolás
Projection: mikor kiválasztjuk mely mező értékekre van szükségung egy selectben vissza.
------------
Spring Data and makes it possible to remove the DAO implementations entirely. Our custom interface of the DAO is now the only artifact that we need to explicitly define.
The DAO interface needs to extend the JPA specific Repository interface, JpaRepository. This will enable Spring Data to find this interface and automatically create an implementation for it.
 Spring Data repository interfaces and their functionality:
    CrudRepository: provides CRUD functions
    PagingAndSortingRepository: methods to do pagination and sorting of records
    JpaRepository: all CrudRepository and PagingAndSortingRepository provided functionalities; provides JPA-related methods such as flushing the persistence context and deleting records in a batch

 by implementing one of the Repository interfaces , the DAO will already have some basic CRUD methods (and queries) defined and implemented:
     @Repository
     public interface ProductRepository extends JpaRepository<Product, Long> {
         Product findByName(String productName);
     }

    CRUDRepository interface, diese sinf by default Transactional:
    save(…) – save an Iterable of entities. Here, we can pass multiple objects to save them in a batch
    findOne(…) – get a single entity based on passed primary key value
    findAll() – get an Iterable of all available entities in the database
    count() – return the count of total entities in a table
    delete(…) – delete an entity based on the passed object
    exists(…) – verify if an entity exists based on the passed primary key value
------------
Constructing Queries in Spring Data (JPA options: JPQL, NAtive sQL, Criteria API):

1. DERIVED QUERY METHODS: Using method naming conventions (geben nicht Optioanl zurück):
    List<User> findByName(String name)
    List<User> findTop3ByAge(); Passenger findFirstByOrderBySeatNumberAsc(); Passenger findTopByOrderBySeatNumberAsc();List<Passenger> passenger = repository.findByOrderBySeatNumberAsc(Limit.of(1));
    List<User> findByNameIsNot(String name); List<User> findByNameIsNull(); List<User> findByNameIsNotNull(); List<User> findByActiveTrue(); findByNameStartingWith; findByNameLike(S
    List<User> findByActiveFalse(); findByAgeLessThanEqual; findByAgeIn(Collection<Integer> ages); findByNameOrAgeAndActive;

2: @Query(JPQL / SQL) Annotation to execute JPQL oder native SQL:   ( https://www.baeldung.com/spring-data-jpa-query )
    - JPQL:
        @Query("SELECT u FROM User u WHERE u.status = 1")
        Collection<User> findAllActiveUsers();

    - Native SQL:
       @Query(
         value = "SELECT * FROM USERS u WHERE u.status = 1",
         nativeQuery = true)
        Collection<User> findAllActiveUsersNative();

    Passing parameters to queries:
        1.  Indexed parameters: ?1, ?2
                @Query("SELECT u FROM User u WHERE u.status = ?1 and u.name = ?2")
                User findUserByStatusAndName(Integer status, String name);
            oder:
            @Query(
              value = "SELECT * FROM Users u WHERE u.status = ?1",
              nativeQuery = true)
            User findUserByStatusNative(Integer status);

        2. Named parameters:
                @Query("SELECT u FROM User u WHERE u.status = :status and u.name = :name")
                User findUserByStatusAndNameNamedParams(
                  @Param("status") Integer status,
                  @Param("name") String name);
           oder:
                @Query(value = "SELECT * FROM Users u WHERE u.status = :status and u.name = :name",
                  nativeQuery = true)
                User findUserByStatusAndNameNamedParamsNative(
                  @Param("status") Integer status, @Param("name") String name);

        3. Update / insert Statement:
            @Modifying
            @Query("update/insert User u set u.status = :status where u.name = :name")
            int updateUserSetStatusForName(@Param("status") Integer status,
              @Param("name") String name);

            oder:
                @Modifying
                @Query(value = "update Users u set u.status = ? where u.name = ?",
                  nativeQuery = true)
                int updateUserSetStatusForNameNative(Integer status, String name);

    3. Criteria API:
    Wir können queries programmatisch zusammenbauen, Vorteil: klarer Objekt-oriented API, sehr gut, wenn wir dynamische Queries definieren wolen.
        Session session = HibernateUtil.getHibernateSession();
        CriteriaBuilder cb = session.getCriteriaBuilder();
        CriteriaQuery<Item> cr = cb.createQuery(Item.class);
        Root<Item> root = cr.from(Item.class);
        cr.select(root);

        Query<Item> query = session.createQuery(cr);
        List<Item> results = query.getResultList();

    Wenn wir aber keinen statischen SQL statment definiren könne, weil wir einen dynamischen Query brauchen -> dann @Query Annotation können wir nicht verwenden.
    Wir können den Spring Repository interface extendieren und als FRAGMENT INTERFACE verwenden:
    https://docs.spring.io/spring-data/jpa/reference/repositories/custom-implementations.html
        1. Wir definieren under suctom repository interface.
        2. Wir implementieren diesen custom interface, mit der Verwendung von Criteria API
        3. Wir extendieren neben dem zB JPARepository interface diesen custom interface in unserem busuiness specific Repository interface, wo wir dann einfach ihre Methoden rufen können.
-----------------
TRANSACTION

Wenn die Methode der CRUDRepository verwendet, dann Transaction managememnt ist by default enabled.
Jó kis példa a transactionra:
https://docs.spring.io/spring-data/jpa/reference/jpa/transactions.html
( https://www.geeksforgeeks.org/spring-boot-transaction-management-using-transactional-annotation/)
A.: Methoden der CRUDRepository sind by default transactional
B.: Wenn wir aber Query mit @Query definieren, dann müssen wir explicit @Transactional verwenden
C.: mehrere DB Operationen in einem Service Method:Eset: ha az employee és a hozzá tartozó addresst is egyszerre kell mentenünk a DB-be.
    1.  wir sollen in Application.java die @EnableTransactionManagement verwenden.
    2. in dem Service MEethod / oder wir können es auf class-level auch die @Transaction vewernden

########################################################################################################################################################################
Json related collection of entities:

ha a sellers collection lazy initialized és nincs is rá szükség akkor ha at entity: @JsonIgnoreProperties(value= {"sellers"}) nincsen akkor exceptiont dob a API mert a jackson
nem tudja jsonná convertáléni a nem létező sellers collectiont. Ezt el lehet kerülni a fenti annotációvalés akkor a json nem is tartalmaz egyáltaláén sellers propertit.
De ezzel az a baj, hogy az Entity-t JsonIgnoreProperties-nal beállítottam rra, hogy a sellers collectiont sose serializuálja  ajasckosn jsonná!
Erre az a jó megoldás, hogy egy olyan custom VO-t deriválunk le az Entityből aminek nincsen sellers collection properitje és aazt serializáltatjuk a REST controllerben.


Két issue:
1. Ha van related collection akkor lehetőleg a jpa provider egyazon selectben szedje össze a többit adatot is
2. illetve a lazy loading menjem
Ezek megoldódnak, ha NamedEntiyGrapho-ot használok:
	@NamedEntityGraph(name = "Book.sellers", attributeNodes = @NamedAttributeNode("sellers"))az Entity class-on

	..és a repositoryban, felülírjuk a JPARepo által implementál gyári metódust:

	@EntityGraph(value = "Book.sellers")
	List<Book> findAll();

https://thorben-janssen.com/5-ways-to-initialize-lazy-relations-and-when-to-use-them/
https://dzone.com/articles/finding-and-fixing-spring-data-jpa-performance-iss

https://thorben-janssen.com/5-ways-to-initialize-lazy-relations-and-when-to-use-them/
ways to initialize lazy associations and when to use them:
	1. Call a method on the mapped relation:
		Order order = this.em.find(Order.class, orderId);
		order.getItems().size();  -> n* query problem

	2.	initialize lazy associations is to use a JPQL query  / Criteria with a fetch join:
			-> Hibernate holt alles in einem query. Nachteil: man soll eine Query schreiben

	3.  NamedEntityGraph: man definiert ein Graoph von verwandten Entitis in Annotation, es ist unabhängig von dem Query.
			@NamedEntityGraph(name = "graph.Order.items", attributeNodes = @NamedAttributeNode("items"))

Using Projection in JPA Repository interface:
https://www.baeldung.com/spring-data-jpa-projections

Closed Projection's Eigenschaften werden durch eine Interface definiert - hier wird title property aus dem Entity genommen:
	public interface BookTitleView {
		String getTitle();
	}
..und diese wird im Repo Method verwendet, kann man das Repository Methoden signaturen verwenden dabei: List<BookTitleView> findByTitle(String title);

Open Projection: interface Methoden haben keine entsprechende property in entity, sondern wird dynamisch aus mehrere properties Werte berechnet.
	@Value("#{target.firstName + ' ' + target.lastName}")
    String getFullName();

Class based projection (herkömmliche): Pojo mit constructor mit den properties aufgelistet als parameters.

hogyan kell egy querit összerakni:
https://www.baeldung.com/spring-data-derived-queries

JOIN  vs JOIN FETCH:
https://dzone.com/articles/how-to-decide-between-join-and-join-fetch

Book on Spring Boot JPA
https://books.google.hu/books?id=dIvgDwAAQBAJ&pg=PA264&lpg=PA264&dq=org.hibernate.QueryException:+query+specified+join+fetching,+but+the+owner+of+the+fetched+association+was+not+present+in+the+select+list&source
=bl&ots=ouIqZUYbx-&sig=ACfU3U0JCYZq-L7Ta8t4D9NYhx9zR9i0RQ&hl=hu&sa=X&ved=2ahUKEwjbs6Krk5fzAhVJposKHQHUDKQQ6AF6BAgkEAM#v=onepage&q&f=false

**************************************************************************************************************************************************************
VALIDATING REQUEST BODY AND PARAMETERS IN SPRING BOOT
https://medium.com/@tericcabrel/validate-request-body-and-parameter-in-spring-boot-53ca77f97fe9
**************************************************************************************************************************************************************
A.: Validating request body:
    In userem endpoint im der Controller Klasse wir kriegen mit http post in request body die Konnektor Daten. Dise nennt man KonnektorDTO (data transfer object), weil es vom controller Schicht die Daten zum service Schicht
    transportiert. In dem DTO Klasse ( kann gelich mit dem JPA Entity sein) die Felder werden mit dem Hibernates Validator API constraints annotiert:

      public class KonnektorDTO {
       @JsonProperty("id")
       private Integer id;

       @NotBlank("The host name is required")
       @JsonProperty("hostName")
       private String hostName;

    in dem Controller wir verwenden @Valid -> wenn Spring findet ein argument mit @Valid , dann es vaklidiert es gelich und wenn es fehlschlägt, dann wirft es MethodArgumentNotValidException. Diese können wir in einem
    ControllerAdvice Klasse mit dem @ExceptionHandler annotirtem Methode behandeln.
    public ResponseEntity<KonnektorDTO> updateKonnektor(@Valid @PathVariable String konnektorId, @Valid @RequestBody KonnektorDTO dto)
B: validating path variable: @Validated anstelle von @Valid !!!! Hier wird jetzte aber ConstraintViolationException  geworfen , wenn...
    @Validated
    @RequestMapping(value = "/reservations")
    public ResponseEntity<Reservation> oneReservation(@Pattern(regexp = "^RSV(-\\d{4,}){2}$") @PathVariable String code)

**************************************************************************************************************************************************************
TESTING
https://www.baeldung.com/spring-boot-testing
**************************************************************************************************************************************************************
Mockito methods:
https://www.javatpoint.com/methods-of-mockito

unit testing with JUnit5 ( Jupiter): https://www.baeldung.com/junit-5

## leirja, hogy mi a @Mock ill @InjectMocj stb, nagyon jó
https://www.arhohuttunen.com/junit-5-mockito/

## @Spy
https://www.baeldung.com/mockito-annotations

## @Mock vagy @Spy ??:
https://stackoverflow.com/questions/15052984/what-is-the-difference-between-mocking-and-spying-when-using-mockito#:~:text=about%20partial%20mocks.-,Mockito.,passed%20to%20spy()%20method.

## verify, mikor gyakorlatilag nincs mire assertelni, de a method hivásokat meg akarjuk csinálni:
https://www.youtube.com/watch?v=lbN2nfsC7C4
KonnektorServiceTest deleteKonnektor_Success

## sql script használata a testhez:
https://www.baeldung.com/spring-boot-data-sql-and-schema-sql
-------
UNIT TEST:
    -   testet man ob ein komponent so funktioniert wie es beabsichtigt wurde.
    -   Sie lauft  in Isolation, d.h. ein unit test ruft beim Ablaufen die dependencies der Komponente nicht auf, sondern es wird gemockt.
    -   Die Reihenfolge der Test beinflusst den Ablauf nicht, kann automatisiert ablaufen. Beim Feature-Erweiterung kann man damit unerwünschte Sieteneffekte aufklaeren.
    -   Test fixture: es ist die JUnit test Klasse, der mehrere Test cases hat, mit beforeEach/beforeAll etc.

Test Aufbau Unit / Integration:
    @Test
    public void shouldReturnItemNameInUpperCase() {

        //
        // Given
        //
        Item mockedItem = new Item("it1", "Item 1", "This is item 1", 2000, true);
        when(itemRepository.findById("it1")).thenReturn(mockedItem);

        //
        // When
        //
        String result = itemService.getItemNameUpperCase("it1");

        //
        // Then
        //
        verify(itemRepository, times(1)).findById("it1");
        assertThat(result, is("ITEM 1"));
}
    - given: ein Ausgangszustand wird initialisiert
    - when:  Die zu testende Operation wird ausgeführt ;die wir testen wollen, kann mocking machen:  when(konnektorRepository.findById(1L)).thenReturn(Optional.of(konnektor))
    - than:  Verifikation, hier werden Assertionen verwendet.

INTEGRATION TEST: Testen der verschiende layers der Apllication in Zusammenspiel, desewegen wird es nicht gemockt manchaml der DB Schicht).
Integration Test brauch, dass der IOc Spring container startet und die Application läuft in dem embedded server.

// egész jó kis leírás, jo tanulos linkekkel az elején
http://webprogramozas.inf.elte.hu/#!/subjects/full-stack/java-rest-test

Testing the REST API:
    Lehetőségek:
        -   Az egeész szerver tesztelése, mikor a szerver is elindul, valamint az egész applicationContext is; ekkor http requesteket küldhetünk a szervernek a restTemplate segítségével, majd a responst
            analizálhatjuk, elemezhetjük a response json-t (@SpringBootTest,  restTemplate)
            lasd hogyan:
                    http://webprogramozas.inf.elte.hu/#!/subjects/full-stack/java-rest-test.
                    https://howtodoinjava.com/spring-boot2/testing/spring-integration-testing/

            itt nem a production adatbázist érjük el, hanem a resources/test_data.sql- t használjuk a test casesben:  @Sql({"/test_data.sql"}) használatával
        -   Az egész alkalmazás, de szerver nélkük: @AutoConfigureMockMvc
        -   Csak a web layert, mit mocking der Abhängigkeiten @WebMvcTest

Alkalmazás
@RunWith(SpringRunner.class)
@SpringBootTest(    // wir bootrappen das ganze Container, es kreiert einen ApplicationContext
  webEnvironment = SpringBootTest.WebEnvironment.MOCK,
  classes = Application.class)
@AutoConfigureMockMvc
@TestPropertySource(
  locations = "classpath:application-integrationtest.properties")
public class EmployeeRestControllerIntegrationTest {

    @Autowired
    private MockMvc mvc;

    @Autowired
    private EmployeeRepository repository;

    Nálam:
        1. Unit test with Mock für Service Klassen
        2. Integration Test für die Service-Repositiry Kommunikation (@SpringBootTest). Dabei wurde die @SQL verwendet, um die testdaten von einem sql Datei zu holen, plus die embeded H2 Database verwendet.
        3. Integration API Endpoint Test mit @SpringBootTest API controller->Service->Repository-> embededd Datenbank.










