// Complete Angular Tutorial For Beginners
https://www.tektutorialshub.com/angular-tutorial/#component-communication

// function-iterables-promises-observables
https://www.telerik.com/blogs/angular-basics-comparing-data-producers-javascript-functions-promises-iterables-observables
// subjects
https://www.tektutorialshub.com/angular/subjects-in-angular/
// BeavoirSubject
https://www.tektutorialshub.com/angular/replaysubject-behaviorsubject-asyncsubject-in-angular/
// Object is possibly undefined error
https://www.jsowl.com/solve-the-error-ts2532-object-is-possibly-undefined-in-typescript/?utm_content=cmp-true
// threads in javascript
https://www.telerik.com/blogs/angular-basics-introduction-processes-threads-web-ui-developers
// @Input
https://blog.angular-university.io/angular-input/
// @ViewChild
https://www.tektutorialshub.com/angular/understanding-viewchild-viewchildren-querylist-in-angular/
// communication between components
https://www.tektutorialshub.com/angular/angular-component-communication-sharing-data/#listens-to-child-event
// injecting
https://www.tektutorialshub.com/angular/angular-injector-injectable-inject/
// services
https://www.tektutorialshub.com/angular/angular-services/
// lyfecycle
https://www.tektutorialshub.com/angular/angular-component-life-cycle-hooks/#ngdocheck
// CD
https://www.telerik.com/blogs/simplifying-angular-change-detection
https://blog.angular-university.io/onpush-change-detection-how-it-works/
https://medium.com/@toha.marko/angular-onpush-check-your-knowledge-on-a-simple-example-bf461b76cef3
https://blogs.halodoc.io/understanding-angular-change-detection-strategy/#:~:text=By%20default%2C%20angular%20will%20run,()%20has%20a%20new%20reference
https://www.telerik.com/blogs/simplifying-angular-change-detection
https://www.telerik.com/blogs/angular-basics-step-by-step-understanding-async-pipe
// DoCheck
https://www.tektutorialshub.com/angular/angular-component-life-cycle-hooks/#ngdocheck
// functional interceptors
https://www.angulararchitects.io/blog/the-refurbished-httpclient-in-angular-15-standalone-apis-and-functional-interceptors/
// Interceptorok felhasználási területei:
https://medium.com/angular-in-depth/top-10-ways-to-use-interceptors-in-angular-db450f8a62d6
// ng-template
https://morioh.com/p/fbef3198c6f0
// SD route parameters
https://www.freecodecamp.org/news/use-input-for-angular-route-parameters/
// rxjs operator
https://rxjs.dev/guide/operators
// rxjs higher order mapping
https://blog.angular-university.io/rxjs-higher-order-mapping/
// observable
https://dev.to/devbyrayray/you-don-t-have-to-use-observables-in-angular-1653
https://blog.danieleghidoli.it/2020/10/30/when-should-i-unsubscribe-from-an-observable-in-angular/
https://medium.com/@gesteira2046/goodbye-to-unsubscribe-in-angular-components-8817e1b21db2
// Promise
https://javascript.info/promise-basics
https://www.w3schools.com/js/js_promise.asp
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises
https://www.syncfusion.com/blogs/post/angular-promises-vs-observables.aspx/amp
// signal
https://www.freecodecamp.org/news/angular-signals/
// 4 ways to listen to events
https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-3-renderer2-listen-14c6fe052b59
// error handling
https://www.tektutorialshub.com/angular/angular-http-error-handling/
https://pkief.medium.com/global-error-handling-in-angular-ea395ce174b1
https://blog.angular-university.io/rxjs-error-handling/
// style, class-binding, NgClass, NgStyle
https://angular.io/guide/class-binding
// DI
https://www.tektutorialshub.com/angular/angular-dependency-injection/
https://www.tektutorialshub.com/angular/how-dependency-injection-resolution-works-in-angular/
https://www.tektutorialshub.com/angular/how-dependency-injection-resolution-works-in-angular/
// ViewProvider
 https://debugmode.net/2020/06/24/when-to-use-viewproviders-in-angular-simplified/
// forms
https://www.tektutorialshub.com/angular/valuechanges-in-angular-forms/
// Object type in TS
https://mariusschulz.com/blog/the-object-type-in-typescript
// performance tuning
https://christianlydemann.com/the-complete-guide-to-angular-performance-tuning/
// property binding
https://angular.io/guide/property-binding
// data binding
https://www.javatpoint.com/data-binding-in-angular-8
// pipes
https://angular.io/guide/pipes
// async pipes - for data communication with between components on onPush
https://www.telerik.com/blogs/angular-basics-step-by-step-understanding-async-pipe
// 4 ways to listen to DOM venets in Angular:
1.  https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-1-event-binding-3ec7e9f51a1d
2.  https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-2-hostlistener-1b66d45b3e3d
3.  https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-3-renderer2-listen-14c6fe052b59
// How to migrate CoreModule to Standalone APIs
https://angularexperts.io/blog/angular-core-module-standalone-migration
// modules in TS:
https://www.tutorialsteacher.com/typescript/typescript-module
// Generics:
https://www.tutorialsteacher.com/typescript/typescript-generic
// async await
https://javascript.info/async-await
//  asynchronous js
https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing
// typescript version
https://marketsplash.com/tutorials/typescript/how-to-check-typescript-version/
// dropdown select html
https://www.telerik.com/blogs/angular-basics-how-to-get-value-selected-dropdown-menu-item



Checking angular version: ng version:
Checking typescript version: tsc --version ( updating to lates version: https://marketsplash.com/tutorials/typescript/how-to-check-typescript-version/)
Miután npm install -g typescript@latest --save  , globálisan a npm-el installáltam a legújab (5.3.3) ts verziót a gépemre. De a package json-ban 5.1.1 verzió volt megadva. Ezt kézzel felülírtam 5.3.3-ra de pirossal aláhúzta ->
futtassam a npm install-t itt a Intellij ben és akkor updateli magát és eltűnik a piros is.
Aztán ng serve ezt a hibát irta ki: Error: Failed to initialize Angular compilation - The Angular Compiler requires TypeScript >=4.9.3 and <5.2.0 but 5.3.3 was found instead.
-> visszadowngradeltem a tsc-t 5.1.3 -re: npm install -g typescript@5.1.3

Checking node version: npm version

Arrays:
  1. Using square brackets. This method is similar to how you would declare arrays in JavaScript.
     let fruits: string[] = ['Apple', 'Orange', 'Banana'];
  2. Using a generic array type, Array<elementType>.
     let fruits: Array<string> = ['Apple', 'Orange', 'Banana'];
Of course, you can always initialize an array like shown below, but you will not get the advantage of TypeScript's type system.
   let arr = [1, 3, 'Apple', 'Orange', 'Banana', true, false];

An array in TypeScript can contain elements of different data types using a generic array type syntax:
  let values: (string | number)[] = ['Apple', 2, 'Orange', 3, 4, 'Banana'];
or:
  let values: Array<string | number> = ['Apple', 2, 'Orange', 3, 4, 'Banana'];

KLONING OBJECTS:
1. shallow copy, no methods copy
  The Object.assign() method copies all enumerable own properties from one or more source objects to a target object
  const target = { a: 1, b: 2 };
  const source = { b: 4, c: 5 };
  const returnedTarget = Object.assign(target, source);
  oder, wenn wir keine target haben nur das Objekt klonen wollen:
  let ujobj = Object.assign({}, source);
2. Spread operator (shallow,  no methods copy):
  const ujobj = {...source};
3. lodash deep copy

Instanz erstellen (Interface Type):
1. von interface Typ:
	const error: Error = {
      name: "pisti error",
      message: "pisti message"
    };
2. Klasse-Typ:
	let ez: Pista = {
		name: "bende"
	};
ohne Tipisierung / Angabe der Klasse:
	let ez = {
		name: "rjkreoirp"
	};

HAHSHATBLE in ts: (nem más mint egy string k
export declare interface SimpleChanges {
    [propName: string]: SimpleChange;
}
let ht: string[]: SimpleChange;

accessing it:

INTERFACES dienen dazu, die Struktur eines Objekts grundsätzlich zu definieren.
Optionale Eigenschaften werden durch ein Fragezeichen-Symbol gekennzeichnet.
	export interface User { // szintaktikája mint a class-nak!
		name: string,
		age?: number
	}
instanzieren interface type object (object literal stilusban):
	const pista: User = {name: 'bende'};    // szemben a objektummal:  pista: User = new ('bende');
	vagy ha array: let pistikek: User[] = [];

TEMPLATE-SYNTAX _> Angular erweiter html syntax mit folgenden Ausdrücken: interpolation {{componentProperty}}, template strings, safe-navigator-operator (?), property binding,
	event binding,  2-way binding, #Elementreferenzen, Direktiven, *Strukturdirektiven, Attributdirektiven, Pipes

TEMPLATE-STRINGS
Mit einem normalen String in einfachen Anführungszeichen ist es nicht möglich, einen Text über mehrere Zeilen anzugeben. TEMPLATE-STRINGS im Code
Backticks, keine zu nutzen. Anführungszeichen Ein Template-String wird mit schrägen `Hochkommata` (auch Accent grave oder Backtick) eingeleitet und beendet, nicht mit
Anführungszeichen. Der String kann sich schließlich über mehrere Zeilen erstrecken und endet erst beim schließenden Backtick. Template strings erlauben
STRING INTERPOLATION: wir können Expressions (Ausdrücke) in das String einbetten.
Interpolatin {{}} innherhalb von template string (backticks)

ARROW FUNKTION = Lambda Ausdruck
Eine Arrow-Funktion ist eine Kurzschreibweise für eine normale function() in JavaScript. Auch die Bezeichnung Lambda-Ausdruck ist verbreitet.
Die Definition einer anonymen function() verkürzt sich damit elegant zu einem Pfeil =>. Erhält die Funktion genau ein Argument, können
die runden Klammern auf der linken Seite sogar weggelassen wer. Der  rechtsseitige den. Ausdruck dient als Rückgabewert. Auch die geschweiften Klammern auf der rechten Seite können
eingespart werden: Lässt man die Klammern weg, wird das Ergebnis des rechtsseitigen Ausdrucks als Rückgabewert für die Funktion verwendet.
Wir müssen also kein return-Statement verwenden.

SPREAD OPERATOR / oder zum klonen : Object.assing(target, source)
Praktisch verwenden wir den Spread-Operator vor allem, um Objekte und Arrays zu klonen. const copy = { ...myObject, year: 2020 }; ( Gleichheitszeichen) kopieren. »Klonen«
 wir also auf diese Weise ein Objekt, das eine Instanz einer Klasse ist, so werden nur die Eigenschaften kopiert, nicht aber die klasseneigenen Methoden. Die inhaltliche Verbindung
mit der Klasse geht verloren, und es wird lediglich eine flache Kopie (engl. SHALLOW COPY) erzeugt. Es wird stets nur die obere Ebene eines Objekts ko
piert. Tiefere Zweige eines Objekts oder Arrays müssen wir zunächst mit der Spread-Syntax einzeln klonen und anschließend neu zusammenbauen. Wird
diese Aufgabe zu kompliziert, sollten wir auf eine Bibliothek zurückgreifen, die eine Deep Copy erzeugt, sodass wir das Objekt gefahrlos verändern können.
Oder lodash cloneDeep methode verwenden.

REST OPERATOR: sollte man eine variirbare anzahl von Argumente in eine Funktion eingeben, so verwendet man (...) Rest operator, dessen Wert man als array verwenden kann.
schaut gleich aus wie spread operator.

DESTRUKUTRIERENDE ZUWEISUNG
Destrukturierende Zuweisungen: Wenn wir einzelne Eigenschaften eines Objekts extrahieren und in Variablen schreiben möchten, so müssen wir die Variablen zuerst an
legen und dann mit den Werten aus dem Objekt befüllen. Mit der Destrukturierung lässt sich dieser Code auf eine Zeile verkürzen: Die Objekt Variablen werden automatisch angelegt und mit
den gleichnamigen Eigenschaften aus dem Objekt befüllt.
Wenn wir nicht alle Property eines Objekt brauchen, dann können wir die Properties extrahieren und in Variablen schreiben:
let {objPropertyName1: newProp1, objPropertyName2: newProp2} = ObjektInstanzdenwirdestrukturieren;
let { neve } = pista;	-> wir extrahieren den neve property in dem pista Objekt;  wenn wir den gleichen Variablennamen erhalten wollen.
oder: const {smcbCard, hbaCard, egkCard, gsmcktCard, gsmckCard, unknownCard} = this.cardTypeForm.getRawValue();

DECORATOR
Es ist eine Funktion, Mit Decorators können wir Klassen, Methoden und Eigenschaften dekorieren und damit Metadaten hinzufügen. Man erkennt einen Decorator stets am @-Zeichen
zu Beginn des Namens.

OPTIONAL CHAINING
Optional Chaining ermöglicht einen sicheren Zugriff auf verschachtelte Objekte, bei denen ein Teil des Objekts potenziell null oder undefined zurückliefert. if (foo?.bar?.baz)
Dabei wertet TypeScript den Ausdruck Schritt für Schritt aus und bricht ab, sobald ein Objekt-Property null oder undefined liefert.
user?name -> wird nicht ausgewertet wenn user ist null, wirft aber Error wenn user ist undefined !!
user?.doMyMethod?()

NULLSIH COALESCING
 Nullish Coalescing: Es erlaubt die einfache Zuweisung von Rückfallwerten, für den Fall, dass eine Variable den Wert null oder undefined hat
 let bar = foo ?? 'backup'; vagy ?? mymethod()

in einer Template können wir den selector (host) element mikt den folgenden css selector zugreifen :host ; und mit :host(.focus) können wir sogar ein focus CSS-Klasse zuweisen.

INTERSECTION TYPE:
Mit itersection Typ kombinieren wir 2 oder mehrere type in einem. Der resultierender Typ wird alle Propertys aller Typen beinhalten.
interface Person {  name: string;  age: number;}
interface Student {  studentCode: string;  division: string}

let student: Student & Person= {
    studentCode:"1",
    division:"10",
    name:"Rahul",
    age:20
}

customer extends person and hat code() Method.
function getCode(obj: Person) {
   if (obj instanceof Customer) {	// diese Verwndung nennt man "TYPE GUARD"
    obj.code();
  } else if (obj instanceof SalesPerson) {
    obj.code();
  }

 INSTANCEOF:
 instanceOf liefert den Typ von Objeckt Typen zurück
 typeof liefert den Typ von primitiv Typen zurück; wenn der Typ Person ist, dann liefert es object zurück und nicht Person
 als Type Guard:  if (typeof money == "string")

 Enum is a set of named constants:
 ENUM TYPEN:
	string enums: enum VehcileType {Car="Car",...
	numeric enums: enum VehcileType { Car, // Typescript weist automatisch numerische Werte zu. startend mit 0;  oder:  Car=2,
	hetero enums: enum VehcileType { Car="C", Plane=1, ..
wenn ein enum const ist, dann wird es nicht transpiled , sondern werden die Werte direkt befüllt in transpiled code.

COMMA OPERATOR: es bewertet die Operand von links nach rechts:
	let x = 1;
	let y = 10;
	x = (x++, y++, x+y)	-> x == 13

VARIABLE SCOPES in TypeScript (mit LET keyword):
	- Global scope: definiert außerhalb von Funktion/Klasse oder code block; erreichbar von überall.
	- Function / class scope: definiert in einer Funktion / Klasse; errichbar dann in der Funktion oder in der Klasse ( class-scoped sind erriechbar in der class-method auch).
	- Local (= block) scope: deklariert in einem code-block. Code block ist mit {} geschweiften Klammern begrenzt, zB. if/try/catch/while/for

VAR keyword ist eine Ausnahme: nur global und function scope, d.h. deklariert in einem block so wird es scoped in the enclosing function.

CONST: muss beim Deklaration gleci ein initial Wert haben. Scopes: global, block.

In Angular Klasseneigenschaften (class property) sind standardmäßig class scoped, dürfen nicht mit let deklariert werden, ebensowenig dürfen sie mit const auch nicht  deklariert w.
Const keyword kann man in Klassenmethoden und außerhalb der Klasse verwenden.

TUPLE type Variable kann multiple datatypes enthalten:
	var user: [number, string, boolean];	// deklariert man tuple variable
	user = [50, 'bende', true]; // Inizialisierung von tuple variable
  Zugreifen auf Tuples Elemente:
	user[0] -> 50
  Hinzufügen nueses Element zum Tuple:
    user.push(50, 'sss', false);
  Tuple ist wie ein Array, kann man array Methoden verwenden. Sein prototype is Array.

#######################################################################################################################################################################################
Complete Angular Tutorial For Beginners
	https://www.tektutorialshub.com/angular-tutorial/#component-communication

PROPERTY BINDING: mit Komponenten kommunizieren

Wir können  Komponente veschachteln und dise können mineinander kommunizieren mittel property binding: in dem Child-Komponente selectors html tag mit property-binding setzten
wir den zu übergebenden Wert von der Host-Komponente, die wir mit dem  @Input()  Decorator in der Chid-Komponente auslesen können.
https://blog.angular-university.io/angular-input/
 Aendert sich die Daaten, wird das binding automatisch aktualisiert. jedes Element im DOM-Baum hat Propertys die sich schreiben lassen.
 [property]="expression"  (ohne eckigen Klammern  wirh rechte Seite als string literar und nicht als expression ausgewertet= Attribute Schreibweise)).
  Wir können belibige Properties in einem  DOM Element schreiben.

  property schreibweise: [property]="expression"
  attribute schreibweise: [attr.atributeName]=expression

 DOM Property in Komponente auslesen: @Input

Jeder Knoten im DOM_Baum ist ein javascript Objekt, die Propertys und Methoden hat, deshalb können wir belibige Eigenschaften(property) in ein DOM-Element schreiben.
DOM-Eigenschaften haben aber keine Auswirkung auf HTML-Quelltext (auf HTML Attribute), wogegen HTML Attribute werden im Queltext notiert und sind immer als Text da,
sie aendern sich waehrend der Laufzeit nicht, diese propertys schreiben aber den Wert den gelichnamigen DOm-proertys, die sich über js Objekt aendern lassen.
 Es gibt DOM properties die nur auf dem javascript Objekt existieren ( textConetnt, innerHTML) und es  gibt html Attribute die keine auswirkung auf js Objekt haben.

DOM Element Property binding: [property]="expr" eckigen Klammern / Anführungszeichen
html Attribute: <img src="angular.png" title="Angular">, diese lassen ich nicht veraenderm , sie sins als plain Text in HTML da, aber wir können die grleichnamigen DOM Objekt
- properties stezten!

Shadow DOM: das innere DOm der Komponente d.h template html selbst, was vom Angular aufgebaut/gelőscht wird: (deswegen ist es shadow DOM gennant)
@Component({
	template: `
    <h1>I am Shadow DOM!</h1>
  `;

Light DOM: Dom , innerhalb der template der komponente: template: `
@Component({
    <child-component>
      <h1>Hi! I am Light DOM!</h1>
   </child-component>
  `
Html attribute     <--Unterschied-->  DOM Objket properties
(unveraenderbar)			lassen sich mit property binding setzten

Html Attribute lassen sich mit Property binding nicht schreiben, dazu sind da: [attr.colspan]="33"

EVENT BINDING damit können wir Ereignisse auf einem DOm Element abfangen und verarbeiten. (myEvent)="myHandler()"
Diese Ereignisse sind entweder native DOM-Events oder werden innerhalb einer Komponente getriggert und diese auf einem Element abfangen und verarbeiten. In der Klasse legen wir
EventEmitter deshalb eine Eigenschaft an und initialisieren sie mit einem so fooEvent genannten EventEmitter. Dieses Objekt brauchen wir, um ein Ereignis auszulösen.
Mit dem Typparameter in spitzen Klammern geben wir an, von welchem Typ der zurückgegebene Payload ist. @Output() fooEvent = new EventEmitter<any>();
myMethod(...): void {
	this.fooEvent.emit(payload);
}
Auf dem DOM-Element können wir jetzt mit einem Event Binding das Ereignis abfangen und eine Handler-Methode aufrufen fooEvent.
<..... (fooEvent)="doitIfFooEventÍfired(); masodikEbentHandlerunk();"

Beschrenkungen:
    1. Wir können nicht auf Erreignisse lauschen, die ausserhalb des Komponents Template ausgelöst wurden.
    1.A. Wir können nicht auf Erreignisse hören, die auf host element (selector) ausgelöst wurden. d.h.:
        wenn wir im parent template haben:
            <cdchild (click)="klikkedChild()" ...dann könenn wir das eventhandler nur im parent Komponent implementieren, nicht aber im child.
        also im Normalfall event muss im childs template ausgelöst werden.
    3. Aber wir können auf Events hören, die auf globalen Elementen ausgelöst wurden: window, document, body: <button (document:click)="handleClick()">Save</button>
    4. Normal DOM events bubble up, d.h. wenn ein Erreignis ist im child ausgelöst, dann es wird im Parent auch gehört, aber custom Errignisse
    5. Wir können event listeners nicht dynamisch zum Template hinzufügen.

#######################################################################################################################################################################################
SERVICE
######################################################################################################################################################################################

https://www.tektutorialshub.com/angular/angular-services/

Ein Service ist eine Klasse, die mit @Injectable() dekoriert ist. mit dieser Decorator sagen wir dem DI, dass es diesen verwenden kann. (d.H. das Service hat dependencies als constructor
parameters deklariert und möchte diese durch das DI zur Vefügung gestellt verwenden : Service sagt dem DI, dass es ein Consumer ist). @Component und @Directive haben implicit @Injectable
decorator, so müssen wir es nicht angeben.

https://www.tektutorialshub.com/angular/angular-injector-injectable-inject/

Wenn man aber kein providedIn hat, dann das service wird sich als dependency nicht beim DI melden -> kann es vom anderen Consumers nicht verwendet werden, kann nirgendwohin
injiziert werden. Ein service kann seine Abhaengigkeiten durch Konstruor-Propertys anfordern (Abhaengigkeiten deklarieren).
 Damit DI über Konstrukor funktioniert,  muss angular wissen welche Klassen zur Verfügung stehen. Es soll ein Bauanletiung geben, wonach DI ein Instanz erzeugt, diese
 Bauanleitung nennt man Provider. Diese Bauanleitung- Registrierung kann auf 2 Wege machen:

	1.	Service wird im einem Module in dem @NgModule() Dekorator's "provider" Eigenschaft angegeben: expliziter Registrierung
	2.	Der Service meldet sich selbst in einem Module @Injectable({providedIn='root'})
		root=singleton per Anwendung, any= lazy Modules haben eigene Insatnze, synchrone Module teilen sich einen einzigen, platform= alle Anwendung teilsen sich (provide: MyService,
		useClass: MyService)

Beim builk js files werden in bundles verpackt, allen Teile die benötigt sind, werden nicht in bubdles eingebaut = Tree-Shaking; Abhängigkeit verwendet wird oder nicht,
läuft das Build-Tool durch den gesamten Baum von Imports. Wenn ein Service existiert, aber niemals von einer Komponente angefordert wird, so ist er trotzdem weiterhin
 im Modul unter providers referenziert. Der Bundler kann (Angular CLI) also nicht herausfinden, ob der Service niemals verwendet wird – und er wird mit in das Bundle übernommen,
 => tree shakableder service wird nicht explicit im Module registriert, sondert meldet sich selbst provider: @Injectable({providedIn: in welches Module
der Provider eingertagen wird.

Primitive Datentypen wie Strings, Zahlen oder boolesche Werte können wir INJECTIONTOKEN bereitstellen.
export const MY_TOKEN = new InjectionToken<string>('myConfig'); providers: [{ provide: MY_TOKEN, useValue: '1234567890' }]
constructor(@Inject(MY_TOKEN) token: string) {

#######################################################################################################################################################################################
Module
######################################################################################################################################################################################

Module sind die gröbsten Bausteine einer Angular-Anwendung. Eine Anwendung besteht aus Modulen, in logische Gruppen und stellen die Teile nach außen zur Verfügung Module können
außerdem Provider in der Anwendung registrieren, die dann im Injector zur Verfügung  stehen. Ein Modul mit all seinen Teilen sollte immer in einem eigenen Ordner organisiert werden.
Bestandteile eines Modules sollten einer einzigen Module gehören,  oder in shared Module unterbringen. Verschidene Funktionalitaeten sollten eigen Feature-Modules haben,
jedes Module kann eigene Routenkonfigurtion module haben. Deklarierte Bestandteile sind nur innerhalb des Moduls verfügbar. Module können Bestandteile aus anderen Modulen importieren.
 Dafür wird die Eigenschaft imports verwendet.  Das zentrale Root-Modul ist der Einstiegspunkt der Anwendung. Für die Darstellung im Browser importiert das Root-Modul
 das BrowserModule. Kind-Module müssen stattdessen das CommonModule einbinden Es wird immer AppModule genannt. Im Root-Modul werden die Routen mit RouterModule.forRoot() registriert,
 in allen anderen Modulen wird RouterModule.forChild() verwendet.

Root Routing Module Definition:
@NgModule({
    imports: [RouterModule.forRoot(routes)]	-> dieses erstellt ein Module, konfiguriert mit dem Pfaden,
})
export class AppRoutingModule {

Child routing Module Definition:, wenn
@NgModule({
    imports: [RouterModule.forChild(routes)]
})
export class BookRoutingModule {

Lazy lodaing child Module im root routing module, Lazy loading modules: Anstatt alle Module in ein großes Bundle zu packen, werden einzelne Bundles angelegt, die erst zur Laufzeit
 vom Server geladen werden. Alles, was wir brauchen, ist die loadChildren Eigenschaft (anstatt component property in der roue def) in unseren Routenkonfiguratione loadChildren.:
{path: "store", // ez lesz a route prefix-je pl "/store/home"
        //  <!-- a children routok componentjeit ide tölti be: <router-outlet></router-outlet> "admin", lásd: admin module path main
        loadChildren: () => import("./store/store-routing.module").then(m => m.StoreRoutingModule)
        , canActivate: [StoreGuard]},


	declarations : gibt alle Komponenten, Direktiven und Pipes an, die Bestandteile dieses Moduls sind
	imports:  importiert andere Module mit ihren Bestandteilen in dieses Modul
	exports: exportiert deklarierte Bestandteile und importierte Module aus diesem Modul
	providers: registrieren wir hiermit dependencies: Service Klassen, Werte und Funktionen als Providers (diese werden durch Dependency Injection zur Verfügung gestellt), sollte stattdessen Injectable
				decorator verwenden, dependencies für DI.
	bootstrap: gibt im Root-Modul die Komponente an, die durch das Bootstrapping geladen wird. Achtung: Array!

Ein Guard ist eine Funktion, die entscheidet, ob ein Navigationsschritt ausgeführt werden darf oder nicht. Diese Entscheidung wird durch den Rückgabewert der Guard-Funktion
ausgedrückt. Guards werden immer als Eigenschaft einer Route notiert. Die zugehörige Methode canActivate() erhält ein Argument vom Typ ActivatedRouteSnapshot.
 Mit diesem Snapshot können wir Informationen zur angefragten Route erhalten, z. B. Routenparameter auslesen. Guard wird als Service implementiert.

#######################################################################################################################################################################################
KOMPONENTE
######################################################################################################################################################################################

standalone-components-v1.pdf

Eine Komponente besteht aus einer TypeScript-Klasse, die mit einem Template verknüpft wird. Die Klasse wird immer mit dem Decorator @Component() eingeleitet,
 Template-URL: Das Template liegt in einer eigenständigen HTMLDatei, die in der Komponente referenziert wird (templateUrl).Inline Template: Das Template wird als (mehrzeiliger)
 String im Quelltext der Komponente angegeben (template). Angular zeigt hier einen neuen Weg auf und ordnet die Styles direkt
 den Komponenten zu. Diese direkte Verknüpfung von Styles und Komponenten sorgt dafür, dass die Styles einen begrenzten Gültigkeitsbereich haben und nur in ihrer
 jeweiligen Komponente gültig sind. Styles  von zwei voneinander unabhängigen Komponenten können sich damit nicht gegenseitig beeinflussen, (Styles URL / Inline styles).
 muss Angular die Komponente allerdings erst kennenlernen. Die reine Existenz einer Komponentendatei reicht nicht aus. Stattdessen müssen wir alle Komponenten der Anwendung
 im zentralen AppModule registrieren( oder im feature-module) .(declarations)
 Komponenten und Direktiven durchlaufen einen festen Lebenszyklus (engl. lifecycle). Dabei werden verschiedene Status durchlaufen.
 Schlussendlich endet der Lebenszyklus mit der Zerstörung der Komponente (engl. destroy), wenn die Route gewechselt wird oder die Komponente mit einer Strukturdirektive
wie ngIf aus dem DOM ausgebaut wird. Dieses gilt für Komponente und Direktive auch:

@Component({
	selector: 'mychild',
	templateUrl: '',
	providers: [{provide: logService, useClass: LogService}],
	viewProviders: [{provide: LogService, useClass: LogJustHereService}]
})
constructor(private logService: logService) ...

STANDALONE Koomponente:
- standalone: true, im Konfigurations Objekt angeben.
- SD werden in keinem Module im declaration property deklariert. Traditional komp gehört einem Module und kann nur da verwendet werden, SD hingegen kann überall spielen.
- SD importiert alle seine Importierte Teile (Komponente, Directive, Pipes NgModules) in eigenem import: [] Property, und wird dazu keine NgModule mehr gebraucht: SD ist sein eigenes Module auch.
- child SD wird vom parent SD in seinem import: [] importiert, und nicht in declaration mehr angegeben. Also SD gehört keinem Module mehr.
- SD kann bootsrapped werden, mit bootsrapAppplication( BootsrappableSD, ...) in main.ts

  https://www.tektutorialshub.com/angular/angular-component-life-cycle-hooks/#ngdocheck

#######################################################################################################################################################################################
CHANGE DETECTION:
#######################################################################################################################################################################################

ist das Mechanismus, wodurch Angular das Template mit dem Komponent synchron haelt. d.h. property binding bleibt immer aktualisiert. Woher weisst Angular,
ob der Wert eines property binding geaendert ist?

    // OnPush vizuális , nagyon jó!!
    https://medium.com/@toha.marko/angular-onpush-check-your-knowledge-on-a-simple-example-bf461b76cef3
    https://blogs.halodoc.io/understanding-angular-change-detection-strategy/#:~:text=By%20default%2C%20angular%20will%20run,()%20has%20a%20new%20reference.

Es starter das CD jedesmal, wenn

DEFAULT
(ChangeDetectionStrategy.Default):
    1.  ein DOM event (wofür ein component handler. aka event binding exisitiert),
    2.  @Input changes ( auch wenn reference to input object bleibt das gleiche aber seine propertiy sind anders),
    3.  setTimeout, setInterval,
    4.  promise, RxJS subscribscion.
Im Laufe des CD cycle Angular prüft jede property binding Wert mit dem entsprechendem Wert in dem Komponent, wertet alle Expressions neu aus, und wenn etwas geaendert hat,
dann aktualiseiert es in dem DOM. Wenn data aendert sich im einem des child Komponente, dann CD wird von oben nach unten den ganzen Komponent-Baum prüfen, ob ein Model anders ist,
und wenn ja, dann rerenderiert das view: also wenn das Initial Anderung im child Komponente passiert, dann werden die mögliche parent auch geprüft.
Dieses kann aber zu Performance probleme führen, dann wenn bestimmte bounded properties schwerwigende  Arbeiten brauchen , dann diese verlangsamen die Anwendung.
Wenn es Wertaenderung findet auf dem komponent dann aktualisiert es  das DOM und ruft die life cycle hooks callback Funktionen auf.
WICHTIG! 
- CD läuft immer von oben nach unten ab, d.h. wenn irgendwo in einem child component ein event ausgelöst wird, dann ausgehend vom root component wird jedes Change detector
aufgerufen und nach unten bis zum letzten compnent ausgeführt. Also, wenn child event (in onPush auch) (button click) ausgelöst, binding on paretn werden auch geupdated.

Mit OnPush wir können CD for Komponente auslassen, die OnPush Strategie verwnden, also wir wollen das CD für ein bestimmten Komponent nicht nicht immer sondern nur in bestimmten
Faellen lauft.!!

Bim ONPUSH strategie, wird CD getriggert werden wenn:
(OnPush):
    1.  @Input data has a new reference
    2.  component oder sein childs triggert an event handler or @HostListener (und nicht überall wie zB. ein Komponent,der kein child ist)
    3.  async pipe emittiert new value
    4.  triggering CD manuell
    Aber nicht  beim: setTimeout, setInterval, Promise, RxJS Subscribscion
    ALSO: mit onpush die betroffene Komponente lauft kein CD extra, wenn parent oder andere komponente ein CD Ablauf auslösen, aber auf sie selbst wird cd ablaufen in den oben genannten faellen.

Wenn OnPush is not working: https://blog.angular-university.io/onpush-change-detection-how-it-works/

https://angular.io/guide/lifecycle-hooks
Lebenszyklus einer Komponente / Directive (lifecycle hooks sing callback Funktionen, die vom Angular gerufen werden wenn bestimmte Errignisse passieren):
	1.	Angular instanziert die Komponente, wobei der Konstruktor aufgerufen und ihre Abhaengigkeiten injiziert werden.

	2.	Change detection startet:
	    A.  Angular prüft und setzt/aktualisiert die input Propertys (@Input) => die Komponente wird inizialisiert. Wenn child comp's @Input propoerty's Wert
	        (its default value) ist geaendert durch das parent component, dann  ONCHANGES wird gerufen beim CD.  Jeder geaenderte! @Input property bekommt ein SimpleCahnge Objekt
	         und SimpleChanges beinhaltet die Instanzen von SimpleChange Objekten.
	    B.  Beim anderen data bind properties wird ONCHANGES nicht gerufen, aber string interpolation und template expressions werden auch ausgewertet:
	        {{szam}} {{kiir()}}

		https://www.tektutorialshub.com/angular/angular-ngonchanges-life-cycle-hook/

	3.	Onchanges: Diese Methode wird aufgerufen, nachdem change detector die data binding @Input geprüft hat (bei anderen data binding changes wird dises callback nicht aufgerufen)
	    und mindenstens eine geaendert wurde. Als Argument erhält die Methode ein Objekt vom Typ SimpleChange, in dem die veränderten Propertys und ihr aktueller und vorheriger
	    Wert angegeben sind.

		(wird nicht aufgerufen wenn input property ein array/Object ist, weil change detection verwendet ===
		  strict equality operator zum Erkennen Aenderung in input propertys. Für pirimitive Typen geht dass, für Objekten wird aber die Referenzen verglichen die gleich sind,
		  so wird Onchanges nicht aufgerufen.
				Lösungen:
					1.	Erstellen ein neues objekt mit den Werten des Alten
					2.	Lagert man die Logik in das Docheck() hinaus.

			ALternative wir können @Input property changes prüfen, wenn wir set / get Metode verwenden, anstatt callback Methode:
			@Input()  set count(count: number) {
                          this._count = count;
                          console.log(count);
                      }
            get count(): number { return this._count; }

	4.	Oninit: signalisiert, dass die Komponente fertig ist, Initialisierunglogik sollte hier kommen, lauft nur einmal ab.

	5.	Docheck: wird IMMER by change detection aufgerufen unabhaengig ob eine Property geaendert wurde oder nicht., besonder beim OnPush.,
	    funktioniert mit array/Objekt-Typen auch.
	    Cd prüft data-binding ausser @Input nach DoCheck()

	6.  AfterContentInit: Content ist hier ein external content injiziert durch ein parent component.
		  gerufen nur einmal nachdem der content inizialisiert und change det abgelaufen ist.in die Komponente projected ist. (Content Projection!),
		  You really don't need to worry about 	it if you're not messing around with templates or <ng-content>. Here @ContentChild and
		  @ContentChildren will be resolved.

	7.	AfterContentChecked: gleich wie oben, aber immer wenn change detection ablauft, Angular aktualisiert properties decorated ,it @ContentChild.

	8.	AfterViewInit: View ist der Template eines Komponents.  nachdem Komponente-View und ihre child views inizialisiert sind. Kann zum extra Initialisierungslogik.
		 Erst ab dieser Stufe im Lebenszyklus können wir mit @ViewChild() zuverlässig auf Elemente in der View zugreifen. Angular compiles all views to JS files, not html -
		 the framework manages templates in code and has a rendering engine to interact with the DOM. At this hook @ViewChild and @ViewChildren will be resolved (aktualisiert)
		 -- child compo

  9.	AfterViewChecked: laeft nach change IMMER detection ab, weil nach beim jedec CD wird das komponent neugerendert.

	10. Ondestroy: Komponente wird aus dem DOM ausgebaut.(man navigiert weg. oder durch	Strukturdirektive wird aus dem DOM ausgebaut )

	Im Generell: Init hooks: wenn view/content ist inizialisiert zum ersten Male. Dieses passiert 1. change detection cycle, gleich nach Instanzierung der Komponente.
				 Checked hooks: Angular prüft ob view/content anders ist.

STANDALONE COMPONENTS:
	with flag: standalone: true
	we can use import property to import other modules, pipes, components into SC:
		import: []
	thus, wir brauchen keine NgModules mehr für unsere SC ( sowie standalone Direktive/Pipes)
	Wir brauchen keinen root module mehr um die appl. zu bootstrappen.

#######################################################################################################################################################################################
ROUTING
######################################################################################################################################################################################

Der ANGULAR-ROUTER interagiert mit der HTML5 History API und verwendet URL-Pfade, um einzelne Zustände zu identifizieren.

	Schritte um Router zu verwenden:
	- Routen konfigurieren: Pfad - Komponente: diese Zuordnung ist die Routendefinition, es ist ein Object : { path: 'mypath', component: MyComponent }. Diese RoDefinitionen werden
		in einem array von Typ Routes festgelegt = routesArray, sie werden in einem separaten Datei definiert.


	- forRoot(): outing module einbauen:
		In simplen Fall: diese routesArray wird in dem root-Module importiert:
			@NgModule({
				imports: [RouterModule.forRoot(routes)] -> im main routing-module. Als Rückgabewert erhalten wir wiederum ein Modul, das mit unseren Routen initialisiert wurde.
				mit forRoot erstellen wir ein RoutingService Objekt. (es darf nur einen einzigen davon geben), und Pfaddefinitionen, aka Routes werden mit Routing Service registriert.

			})

	- forChild(): Für die Navigation wird ein separater Rouer-definition Datei erstellt, und in dem navigations-feature module mit RouterModule.forChild() importiert. 	Und vwerwenden
	  RouterModule.forChild(array) in feature router modules, forChild erstellt aber keinen RoutingService Objekt, sondern werden die Routes (Pfad-component
	  Definitionen mit dem Routingservice registriert, die mit forRoot erstellt wurden.)

	- lazyLoading: geht es um lazy loaded module: routing module für der jeweiligen feature-Module wird im Routing-Definition Objekt mit loadChildren.. property importiert.
      also RoutenDefinition : {path: '..', anstelle von 'component' loadChildren: () => import("./nyomonkovetes/shared/nyomonkovetes-routing.module").then(i => i.NyomonkovetesRoutingModule)},}
	  erstellen wir wiederum ein array of Route Types, wo path: book ist und anstatt component:

	Mit standalone:
		Anstelle RouteDefinitionen mit forRoot() in root/feature Module zu registrieren:
		in app.routing.ts definieren wir eine Array von Routes ( mit möglicher loadChildren/loadComponent für lazy loading), die man in app.config.ts mit provideRouter(APP_ROUTES) Function 
        verwenden, um die Router zu registrieren. Diese app.config.ts wird dann im main.ts als paramter im bootstrapApplication(config) verwendet.
        



	- Komponente anzeigen: <router-outlet name="main"> ist ein Platzhalter das vom Router dynamisch durch geladene Komponente ersetzt wird, zeigt geroutete Komponente an, und mit dem
		name attribute können wir mehrere router-outlet in der Anwendung verwenden.
		was eine Single-Page-Applikation ausmacht: Die Anwendung wird einmalig geladen, und beim Wechsel der Route wird nur jeweils die zu ladende Komponente ausgetauscht und der
		DOM des Kompoenents aus/eingebaut.
		Beim Klick auf einen normalen Link wird die gesamte Seite neu geladen. Die Anwendung wird also beendet, und dieselbe Anwendung wird unter der neuen Adresse neu geladen und gestartet.
		Das Attribut darf 'href' also für Links auf interne Angular-Routen nicht verwendet werden, nur für externe.

	ROUTENPARAMETER:  ':id',{ path:'mypath/component: MyComponent } => <a routerLink="/myPath/42">Link auf 42</a> , Zum Auslesen von Parametern bietet der Router die Klasse
	ActivatedRouteSnapshot, die Auskunft über die gerade aktivierte Route und den  Zustand des Routers gibt.

Routing with SD standalone components:
standalone-componetns-v1.pdf

Da keine Module mehr verwendet werden, wir werden kine RouterModule mit Routes Array Konfigurieren und diese in Modules laden. Anstetten Routes werden in main.ts konfiguriert: 

in main.ts:
    A.: 
        wir können routes und providers dirkt im main.ts Datei angeben:  
        bootstrapApplication(AppComponent, {	// standalone component, was bootstrapped wird
          providers: [
            importProvidersFrom(HttpClientModule), // importing providers from modules usually
        
            // we add routes to the bootstrapApplication configuration
            // wir können child rourtes oder auch einzelne Komponente auch lazy loaden
            provideRouter([
                {
                path: 'navigation',
                  loadChildren: () => import('./app/core/navigation.routing').then(r => r.NAVIGATION_ROUTES)
                                                      // lazy loading  navigation child routes
                                                      // we set loadChildren property to a dynamic function, we import the file dynamically,
                                                      // when the file/with Routes inside is loaded, we have can load/pull in our routes definitions
                },
                {
                  path: 'navigationerror',
                  component: NavigationErrorComponent  // loading component eagerly
        
                },
                {path: '',    						   // lazy loading single standalone component
                  loadComponent: ()=> import('./app/core/welcome.component').then(e => e.WelcomeComponent)
                }, 									   // accessing with outer route
                {path: '**', component: TemplateComponent}
              ],
              withDebugTracing(),
              // withPreloading(PreloadAllModules)
            ),

    B.:
            Oder in app.routing.ts und app.config.ts:
    https://www.angulararchitects.io/blog/the-refurbished-httpclient-in-angular-15-standalone-apis-and-functional-interceptors/
            Anstelle RouteDefinitionen mit forRoot() in root/feature Module zu registrieren:
            in app.routing.ts definieren wir eine Array von Routes ( mit möglicher loadChildren/loadComponent für lazy loading), die man in app.config.ts mit provideRouter(APP_ROUTES) Function
            verwenden, um die Router zu registrieren. Diese app.config.ts wird dann im main.ts als paramter im bootstrapApplication(config) verwendet.

            ApplicationConfig Interface declares eine Array von providers, die für root component und alle seine Kinder zur Verfügung stehen sollen
            Also, wir registrieren Services mit dem root injector in main.ts so:   https://angularexperts.io/blog/angular-core-module-standalone-migration)
            export const appConfig: ApplicationConfig = {
                // registering providers with the root injector
                providers: [
                    importProvidersFrom(HttpClientModule, RouteCommonService),               // importing providers from modules
                    provideRouter(APP_ROUTES, withComponentInputBinding()),             // 
                    provideHttpClient(withInterceptors([pistiInterceptor])),            // configures HttpClient Service -functional Interceptor (ang 16 style)
                    {provide: ErrorHandler, useClass: GlobalErrorHandler},              // also registered with the root injector
                    {provide: RouteCommonService, useClass: RouteCommonService},                  //  registering service for used by a group of child components commonly for data shareing
                    {provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: true},      // registering class-based old ( before version 16) style interceptor
                ]

ROUTES PARAMETER MAPPING in SD: https://www.freecodecamp.org/news/use-input-for-angular-route-parameters/
    ActivatedRoute Service wird seit version 16 nicht mehr verwendet. Seit version 16 wir verwenden @Input properties um route parameter zu lesen. Davon muss aber Angular wissen:
    app.config.ts : provideRouter(APP_ROUTES, withComponentInputBinding())
    

Geminsames Service für eine Gruppe von Komponente:
Environmental Injectors: mit Modules, alle lazy modules hatten ihre eigene Injectors, mit SD alle Route können eigene Injector haben. Also ein gemeinsames Injector und damit ein 
gemeinsames Service für alle children Komponente. D.h. wir können alle Routes mit providers array versehen, und so bekommen diese ( auch non-lezy routes auch, nicht wie beim Modules
eigene Injectors=> gemeinsames Services) ein eigenes Injector. Jetzt sind alle environmental injectors: root injectors auch.

    export const NAVIGATION_ROUTES: Routes = [
        {
        path: '',
        component: TemplateComponent,
        //canActivate: [navigationGuard],
        //providers: [MyCommonService]
        
            children: [
              {
Wir sollten aber meistens providedIn: root verwenden, weil diese ermöglicht lazy loading jetzt schon.

#######################################################################################################################################################################################
REACTIVE PROGRAMMIERUNG
######################################################################################################################################################################################

: Reactive Extensions für JavaScript (RxJS): Datenströme verarbeiten, zusammenführen, transformieren und filtern – das ist die Grundidee der reaktiven
 Programmierung.  Alles als ein Datenstrom auffassen lässt: nicht nur Ereignisse, sondern auch Variablen, statische Werte, Nutzereingaben, Objekte wie Book.

Producer und Subscriber:
	Datenstrom: Wir erstellen eine JavaScript-Funktion mit dem Namen producer() (weil es Werte produziert) . Als Argument erhält diese Funktion  ein Objekt, das drei Eigenschaften
mit Callback-Funktionen besitzt: next, error und complete. Dieses Objekt nennen wir SUBSCRIBER. const mySubscriber = {next: value => console.log('') .....
Wir haben eine Funktion entwickelt, die Befehle ausführt und  ein Objekt entgegennimmt, das drei Callback-Funktionen enthält.

	Producer/Subscriber -> Observable/Observer
	Wenn im Programmablauf etwas passiert (synchron oder asynchron), wird eines dieser drei Callbacks aufgerufen. Die Producer-Funktion emittiert also nacheinander verschiedene
Werte an den Observer. Der ist ein Observable EventEmitter, der HttpClient gibt Observables zurück , und auch Formulare und der Router propagieren Änderungen mit Observables..

	Das Observable ist ein Wrapper um eine Producer-Funktion. Um den Datenstrom zu abonnieren, übergeben wir einen Observer mit drei Callbacks. Der Producer ruft die Callbacks auf,
	sobald etwas passiert.
	-	Das Observable besitzt die Methode subscribe(), mit der wir den Datenstrom abonnieren können, als Argument übergeben wir den Observer. Observer muss nicht alle Callbacks
		implementieren, darin untersceidet es sich vom Subscriber.
	-	Ein Observable besitzt die Methode pipe(). Damit können wir so genannte Operatoren an das Observable anhängen, um den Datenstrom zu verändern
	-	Das Observable wandelt intern den Observer (partielle Implementierung der 3 Callbacks) in einen Subscriber (implementiert intern alle 3 Callbacks)cardTerminalsRoutes).

Observable creation function:
	-	Die Funktion of() nimmt eine Reihe von Werten als Argumente entgegen und erzeugt ein Observable, das diese Werte synchron unmittelbar nacheinander emittiert und
		schließlich completet, also den Datenstrom beendet.
	-	Die Funktion from() zur Erzeugen Observable from Arrays  kann übrigens nicht nur Arrays entgegennehmen, sondern auch Promises, Iteratoren oder andere Observables.
	-	Weitere creation functions: timer(), interval()

  https://rxjs.dev/guide/operators

OPERATORS: Datenströme zu transformieren, zusammenzuführen oder zu filtern und daraus neue Datenströme zu erzeugen. Technisch ist ein Operator eine Funktion, die ein Observable
entgegennimmt, den Datenstrom verarbeitet/verändert und ein neues Observable mit dem geänderten Datenstrom zurückgibt. Damit wir einen Operator auf ein existierendes Observable
anwenden können, benutzen wir die Methode pipe().
	- 	map: transformiert die Werte eines Datenstroms, indem eine Funktion auf jedes Element angewendet wird. Wir übergeben eine sogenannte Projektionsfunktion.
	-	filter: die Elemente eines Datenstroms nach bestimmten Kriterien aussortieren, Prädikatsfunktion.
	-	scan: damit (reduce()) können wir die Elemente des Datenstroms zu einem einzigen Ergebnis zusammenfassen. Der bekannteste Fall einer solchen Reduktion ist die Summe.
	-	retry(): tritt im Observable ein Fehler auf, dann erstellt der Operator eine neue Subscription.

COLD OBSERVABLE: liefert nur dann Werte wenn ein Observer darauf subscribiert ist. Gibt es mehrere Subscriber, dann werden die Methoden mehrfach ausgeführt, d.h. für jeder Subscriber
wird ein neuer Http-Request ausgeführt.
HOT OBSERVABLE: liefert Werte dann auch wenn kein Subscriber ist, und liefert den gleichen Wert (wird ausgeführt) ( einziger Http Request) für alle Zuhörere.
(wie EventEmitter)
Beispiel: cold Ob in hot Ob. umwandeln, damit ein einziger Http-Request ausgeführt wird für mehrere Subscribers:
	const httpShared$ = http$.pipe(share());
	httpShared$.subscribe(e => console.log(e));
	httpShared$.subscribe(e => console.log(e));

Erstellen eines Observables (maunell):
  let mybookObs: Observable<Book> = of(mybook);
  .. wobei außerhalb der Klassendefinition das mybook ist:  const mybook: Book =   {   id: '3333', ... sellers:  []};

PROMISE vs OBSERVABLE:
https://dev.to/devbyrayray/you-don-t-have-to-use-observables-in-angular-1653

https://blog.danieleghidoli.it/2020/10/30/when-should-i-unsubscribe-from-an-observable-in-angular/
https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-3-renderer2-listen-14c6fe052b59

 The difference between a Promise and an Observable is that the first just emits one value and completes, while the latter opens a stream of events and keep listening until
 we unsubscribe from it. That subscription keeps going even after the Angular component doesn’t exist anymore.

 SUBSCRIPTION: ist ein Objekt, das ein Observable representiert, hat nur einen Method: unsubscribe, womit man das Observable wegwirft.

OBSERVABLE:
    -   Öffnet ein Strom von Events und lauscht darauf fortwährend.
	-	Kann synchron und asynchron Operatrionen ausführen.
	-	Wenn Instanziert es macht nichts, bis darauf abbonniert wird.
	-	Man kann cancel/unsubscribe von ihm, oder cancelt sich selbst wenn ein error erfolgt.
	-	Es liefert ein stream von Daten (chat, live streaming etc)
	-	Kann man den Datenstrom mit Opertoren bearbeiten. https://rxjs.dev/guide/operators
	-	Muss haendisch unsubscriben, ansonsten bleibt es offen, sogar naxhdem der komponent zerstört ist.
	Verwendung:
		-	wenn Daten aendern sich haeufig: chat, streaming, notifications.
		-	oder wenn der User sehr oft Aenderungen macht: collapsing menus, form fields Aenderungen: valueChanges und statusChanges.

PROMISE:	https://javascript.info/promise-basics
    -   Emmitiert einen Wert und dann schlieest sich (resolves) oder hat ein error (rejects). States: pending, fulfilled, rejected
	-	es kann resolved or rejectd, kann nicht abbonniert werden oder manuell unsubscribiert werden.
	-	Liefert einen einzigen Wert zurück, gleich wenn es erstellt ist.
	-	immer asynchron.
	Verwendung:
		-	Form submission.
		-	Abfragen von grossen Datenmengen zur single Anzeigen

 NO unsubscribe from:
					-   httpClient Observables
					-	ActivatedRoute Observables like Routing parameters
					-	Observable erstellt mit of(), from()
 Must unsubscribe:
					-   from  manually created Observables
					-	FormGroup observables like form.valueChanges and form.statusChanges
					-	Observables of Renderer2 service like renderer2.listen

	private userSubscription: Subscription;

	ngOnInit() {
	  this.userSubscription = this.userService.userChanged.subscribe(user => {
		console.log(user);
	  });
	}

	ngOnDestroy() {
	  this.userSubscription.unsubscribe()
	}

PROMISE FROM OBSERVABLE ( wenn wir nur data holen):
    async open() {
        const $auditlog =  this.defaultService.getAllAuditLog(this.konnektor.id!);  // retrieving Observable
        await lastValueFrom($auditlog).then(                                        // getting a Promise
            result => {
            const modalRef = this.modalService.open(AuditlogModalComponent,  { size: 'xl' });
            modalRef.componentInstance.auditlogs = result;
            },
            error => {
            this.toast.error((error as HttpErrorResponse).message);
            });    
    }

Async vor dem function: der Methode gibt immer ein Promise zurück, d.h. Rückgabewert wird immer als ein resolved Promise eingehüllt.
 async myFunction() {
    return 1;
    }
..dann :
    myFunction.then(..something);

await lässt javascript warten bis Promise settled wird und einen Wert zurückliefert. d.h. wir brauchen then() nicht mehr:
    Methoden aufruf pausiert beim await bis Promise resolved wird und ein Wert zurückgibt, so js engine kann etwas anderes auch machen.
    await kann man nur verwenden, wenn async da ist. ErrorHandling: mit try/catch Block, anstelle von .catch() Methode

    async -> Funktionrückgabewert wird ein Promise
    await -> anstelle von Promise.then()

    async loadData() {
        1.  let promise$ = new Promise(...);
        2. let promise$ = fetch("http:/...json");
        3. let observable$ = httpClient.getAllKonnektors(...);
        try {
            let result = await promise$;
        } catch (error) {}
    }

RxJS Operators:

https://javascript.plainenglish.io/most-frequently-used-rxjs-operators-with-use-cases-7645639317fc
Higher order RxJS Operator: anstetten von mapping mit herkömmlichen map() Operator ein Wert x in ein Wert y, diese operatoren mappen einen Wert in ein Observable; so das Ergebnis ist
	ein higher-odrder Observable, wofür wir ebenso abbonieren können.

Zb: user editiert form Felder und bei jedem Aenderung wird ein backend Aufruf stattfinden, um den neuen Wert im DB zu speichern: hier wird jedes mal wenn etwas eingetragen wird,
 ein neues Observable erstellt und dafür abboniert, dann http request versandt. Wenn user schnell tippt, dann werden mehrere Observables erstellt , welche wird dann durchgeführt
 und welche wird suspendiert etc?:

concatMap: save Operations werden sekvenziell , nacheinander durchgeführt, wenn 2. wird schneller als das 1. durchgeführt, dann 2. wird warten. Reihenfolge der Observables result
           lieferung ist konstant. Zeitlichen Reihenfolge.

mergeMap: hier werden Observables nicht sequentiell durchgeführt, sondern für allen wird abboniert und wie sie durchgeführt werden, so werden ihre Werte gleich genommen, ohne auf ein
	vorige Observable zu warten. Össze-vissza hozhatják vissza az adatokat.

switchMap:  Während 1. Observable liefert Werte zurück, 2. Observable startet auch Werte zu liefern -> 1. Observable wird unsubscribiert, mit der Folge dass ihre weitere Werte nicht in das
	außere Observable genommen wird. Also, wenn ein späterer Observable Werte liefert, dann frühere wird unsubscribiert. Gut für autocomplete. Das Letzte gewinnt Prinzip.

https://blog.angular-university.io/rxjs-higher-order-mapping/

DEBOUNCE:
man möchte bermeiden, das ein erigniss zu often ausgelöst wird, zB wenn User schnell nacheinander Button kilckt, oder in input filed tippt er schnell, und damit wird bei jedem Buchstaben 
ein http request versendet. Dagegen wir verwende debouceTime Pipe um request zu verzögern.
we can debounce using RxJS operator debounceTime() on a form control's valueChanges observable:

 ngOnInit() {
	this.formCtrlSub = this.firstNameControl.valueChanges.debounceTime(1000).subscribe(newValue => this.firstName = newValue);
	}

Unsubscribing from Observables:
https://medium.com/@gesteira2046/goodbye-to-unsubscribe-in-angular-components-8817e1b21db2

PROMISE:
https://javascript.info/promise-basics
    let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("done!"), 1000);
    });
    
            syntax von then():
                promise.then(
                function(result) { },
                function(error) { }
                );

    // Consuming Funktion kann mit then() registriert werden.
    // resolve runs the first function in .then
    promise.then(
        result => alert(result), // shows "done!" after 1 second
        error => alert(error) // doesn't run
    );
    // sind wir nur in errors interessiert: catch()
    // finally( () => {})

SUBJECT:
    Subject ist ein Observable und Observer in einem:
        -   Es ermöglicht Werte an mehrere observers zu liefern / emmitieren ( multicasting). Es hat subscribe Methode, es hat eine Kolletion von.
        -   Es ist hot observable: es starten Werte zu emmitieren ohne auf Subcriber zu warten.
        -   Es ist ein Observer auch: mit next, error, complete callback Funktionen, also er kann auf ein Observable lauschen, und so Werte zu bekommen ( kann also als ein Bridge funktioneieren).
        Typen: 
            BehaviorSubject: braucht einen Anfangswert, speichert den aktuellen Wert und emmitierts es dem neuem Subscribers. D.h. observer bekommt den letzten aktuellen Wert noch, aber wenn er nach
                            complete() subscribiert dann schon nix.
            ReplaySubject:
            AsyncSubject:


#######################################################################################################################################################################################
ERRORHANDLING:
#######################################################################################################################################################################################

Zwei Typen von Errorbehandlungen:
1.	Fehlerbehandlung in asynkron Code:
    HTTP ERRORS: 
    HttpClient faengt Errors ab und packt sie in HttpErrorResponse (beim Observavble und Promise auch) Objekten, bevor es diese zu der Anwendung weitergibt.
    A HttpErrorResponse is a response that represents an error or failure, either from an un-successful HTTP status, an error while executing the request, or some other failure which
    occurred during the parsing of the response.
    Any error returned on the `Observable` response stream will be wrapped in an `HttpErrorResponse` to provide additional context about the state of the HTTP layer when the error occurred. The error property
    will contain either a wrapped Error object or the error response returned from the server.

		Zwei Unterkategorien des http errors:
			a: Backend server generiert ein error und sendet das response mit Status Code zurück. Angular stellt error und error repsonse Propertys auf der HttpErrorResponse ein.
			b: Client-side Error, wenn request erstellt ist, und zb Network failure ist oder ein Exception passiert in einem RxJS Operator und dabei wird ebenfalls ein HttpErrorResponse
				vom HttpModule zurückgeschickt.

		utility projekt: http-error.service.ts

		Strategien zur Abfangen Errors:

		-  Mit der catchError Operator (empfaent ein Observable und returns auch ein Observable!), worin man es gleich behandelt oder
			mit throwError weiterwirft. Ein Observale liefert keine Daten mehr wenn error erflogt, aber wir können nochmals auf das Observable abbonieren: retryWhen, delayWhen

				https$.pipe(
					catchError(
						A.: err => of([])
						B.: err => throwError(err)
						)
				)
				.subscribe(
					res => console.log('HTTP response', res),
					err => console.log('HTTP Error', err),
					() => console.log('HTTP request completed.')
				);

		-	Errors in der komponenten innerhald bder subscribe Methode behandelt:
			let observer = {
						  next: (response: any) => console.log("next:", response),
						  error: (err: any) => this.errorObject = err // verpackt in HttpErrorResponse
							 }
			this.restDS.get404StatusCode().subscribe( observer );


			this.http.get<repos[]>(this.baseURL + 'usersY/' + userName + '/repos')
				  .pipe(
					catchError( err => {
					  console.log('error caught in service')
					  console.error(err);

					  //Handle the error here
					  // 1. "Catch and replace strategy": we return a fallback value; error subscriber callback method will never be called, and Observable completes!!!
							of([])

					  // 2. rethrowing error, error callback can handle it again later in the chain:
							console.log('Handling error locally and rethrowing it...', err);
							return throwError(err);

					// we can use finalize operator, das immer durchgeführt wird.
					finalize(() => console.log("first finalize() block executed")),
			 		})
				  )

			// wenngleich error in service abgfenagen und teilweise behandelt wird, kann sein dass die error im service mit trhowError Funktion weitergeworfen sollte, damit man
			in der Komponenten ein alert popup oder was aehnliches dem User anzeigt.

		-	in den Komponenten, mit error callback von dem subscribe Methode, drawback we can not return a falback value if error comes:
			  (error => {
					  if (isClientError(error)) {
						...doSomething...
					  }
					})

		-  allgemein (globally)  in Interceptoren: dieses ist die beste Lösung, andernfalls sollten wir in Komponenten/Services repetitive code schreiben, besser alles in Interceptor
			auslagern. HttpInterceptor ist ein Service die erstellen und registrieren global in dem root Module. Dieses faengt alle eingehende und ausgehende Requests.
			Generelle Errors werden mit Interceptor behandelt, für API spezifische Errors werden entweder in der Service's catchError() Operator abgefangen und weitergeworfen,
			oder(und) in der Komponenten in der Observers error Property callback handler.
            STANDALONE INTERCEPTOR: https://medium.com/@bhargavr445/angular-httpinterceptors-standalone-applications-part-5-dd855f052d45
            Ab version 16 functional interfaces oder class based interfaces, vorher nur class based interfaces.
            Functional means:
            


	2.	FEHLERBEHANDLUNG IN SYNKRON CODE:
        - Mit try/catch Block: nicht ausreichend in Applikationen, wo Ein Exception überall passieren kann.
        - GLobal Fehlerbehandlung in ANgular: 
           Standardmaessig Angular verwendet ErrorHandler Service und ruft handleError() Methode für jede unbehandelte Errors auf,
            die dann zum Browser Console ausgeschrieben werden. 
            Errorhandling Strategien für Client side errors: Wir extendieren die ErrorHandler Klasse als Service, und überschreiben (overrride) handleError() Methode,loggiert zum Server back
            und leitet zu einer error page weiter. Wir verwenden global error h. für alle unbehandelte Errors
            (ansonsten sollte man mit try catch auf die	error seite leiten).
            utility projekt: runtime-error-handler.service.ts amely extendálja a ErrorHandlert és ez rakja ki az a bazi nagy piros hiba popup overlay üzenetet, ez a handleError metódusát
            az Angular maga hivja meg ha valami gebasz van!!

creating Promise manually: https://www.educba.com/typescript-promise/

        ERROR HANDLING WITH PROMISE: mit then und catch functions:
        
        await this.defaultService.getKonnektor(this.konnektorId).toPromise()
        .then( result => {
        this.konnektor = result;
        this.loadFormData();
        })
        .catch( error => {
        const err = error as HttpErrorResponse;
        this.toast.error(err.message);
        }
        )

#######################################################################################################################################################################################

CLI: Sie unterstützt uns beim Anlegen von Komponenten, Services und Modulen, stellt einen Entwicklungswebserver bereit, startet die automatischen Softwaretests.

#######################################################################################################################################################################################
REACTIVE FORMS
######################################################################################################################################################################################

Die Grundidee der Reactive Forms ist, dass das komplette Modell des Formulars in der Komponentenklasse angesiedelt wird. Das bedeutet, dass nicht mehr nur die reinen
Eingabedaten in einem Objekt in der Klasse gespeichert sind, sondern alle logischen FormControls mit ihren Zuständen, Validierungsregeln und Werten. jedes unserer Formularfelder wird
durch ein FormControl repräsentiert. Eine Menge von FormControls in einem Objekt zusammenfassen: einer FormGroup, es ist das Model für den Form. FormGroup verwaltet das Status und Wert der 
Form ControlsDas FormArray besitzt Methoden: mit push() können wir weitere Controls
 am Ende anfügen; zm Entfernen removeAt() bzw. Einfügen insert(). Template mit dem Model verknüpfen: formControlName="lastname". FormBuilder: Klasse, die das Kreieren von FormControll,
 
    Wir können FormBuilder Service verwenden, um Controls einfacher zu generieren.
	this.bookForm = this.formBuilder.group({    // vagy  this.formBuilder.nonNullable.group ...
      id: [book?.isbn],
      isbn: [{value: book?.isbn, disabled: this.modes == Modes.edit}, Validators.minLength(3)], ...

    nachedem wird das Model (FormGroup) in dem Komponent gemacht haben, wir müssen das  FormControl mit dem input field in der Template ( mit formControl Directive) registrieren:
    <input id="id" [formControl]="id">

	Mit setValue() können wir die Werte des gesammten Formulars Model neu setzten. Mit patchValue() einzelne Felder: bookForm.patchValue({username: 'pisti'});
	we are also checking for the dirty & touched. Because we do not want the application to display the error when the form is displayed for the first time.
	dirty: A control is dirty if the user has changed the value in the UI.
	touched: A control is touched if the user has triggered a blur event on it.

	Jedes FormControl, FormGroup und FormArray besitzt dafür zwei besondere Propertys: valueChanges und statusChanges. Dahinter verstecken sich Observables, die sich immer dann melden,
    wenn sich der Formularwert ändert (valueChanges) oder der Formularzustand (status-Changes). Wie jedes Observable können wir diese Änderungen abonnieren und weiterverarbeiten.
    ( this.myForm.valueChanges.subscribe(groupValue => console.log(groupValue)); )
    ( this.myForm.get("username").valueChanges.subscribe(groupValue => console.log(groupValue)); )
    let streetNumber = this.myformModel.get("address.street")!.value;
    this.myformModel.controls.foodOpetionsArray.push(new FÍormControl(''));
    D.h: wir können änderungen nicht nur in einzelnen Formfelder überwachen, sondern die einer FormArray mit mehrerern FormControlls auch!
   

	TYPE ASSERTION: mit dem Schlüsselwort "as" machen wir Objekt-Type casting: this.bookForm.get('authors') as FormArray;

Custom Validator: als statische Methode oder als Service implementieren. Die Validierungsfunktion erhält als Argument ein AbstractControl (BasisKlasse für FormControll..etc) und als
Rückgabewert gibt ValidationError Objekt wenn ungültig , oder null wenn gültig ist.

Wir können ein einzelnen Feld validoeren, oder eine Gruppde von FormControlls auch, wie ein FormArray.
Ausschreiben der error msg in der template:
FormControll hat ein errors Eigenschaft
 <span class="invalid"  *ngIf="bookForm.get('title')?.errors" translate>{{bookForm.get('title')?.errors.title.message}}</span>

#######################################################################################################################################################################################
PROJECT STRUCUTRE
######################################################################################################################################################################################

NODE.JS ist eine Laufzeitumgebung  für JavaScript. Karma, ESLint, JSHint, TypeScript-Compiler und Angular CLI sie wurden in JavaScript geschrieben und werden mit Node.js ausgeführt.

NPM: Pakete verwalten, können JavaScript, CSS, HTML und mehr beinhalten.

File Struktur:
	angular.json: Konfigurationsdatei für workspace,  hier befinden sich einige Optionen, die das Verhalten von Angular CLI und seine Kommandos steuern. Dieser Datei besteht aus Bereichen, zB.
		-	version
		-	projects: In einem Angular-Projekt existiert auf oberster Ebene immer ein sogenannter Workspace. Dieser wird beim Aufruf über  ng new  erzeugt. Das workspace kann aber
			mehrere Projekte und Bibliotheken beinhalten, diese werden wiederum in "project" Beraich konfiguruiert. ( Monorepo workspace) .
			Schemantics: ein Code-Generator in Angular CLI, mit dem wir zb componente generieren können aus dem command line.
		-	architect: für die Konfiguration von Angular-CLI Kommandos wie zum Beispiel ng test / build / serve / configurations ( production= Diese beinhaltet die Optionen
			+ serve:  Konfiguration für Starten eine Appl für Entwicklung
			+ build: Konf. für Kompilieren und Verpackung
			+ Production optimization
			+ Test Konfigurationen

			für das Bauen einer Produktivversion Ihrer Anwendung  / dev) ( mit Konfigurations-Objekten)

	package.json: Hauptkonfigurationsdatei, wird beim Erstellen des Projekt erst generiert.  die die Abhaengigkeiten des Projekts definiert. Mit npm werden Pakete in node_modules Verzeichnis installiert.
		-	name, version
		-	dependencies: alle Abhaengigkeiten, die die Anwendung beim Laufen braucht.
		-	devDependencies: -||- die nur bei der Entwickulng braucht.
		-	hier kann man scripts konfigurieren: Skripte, die man über npm ausführen kann. (zB: "json" -> npm run json

	package.lock.json: beinhaltet Abhangigkeiten wie package.json, aber mit dem exakten Versionsnummer.

	tsconfig.json:

	tsconfig.base.json: Optionen angegeben, die vom TypeScript-Compiler gelesen und verarbeitet werden.
		-	baseUrl, sourceMap (true= Komplier generiert .js.map Dateien und so kann man durch ts files durchschreiten und nicht durch die generierten js files),
			target (javascript version für ts), module (module loader)

	tsconfig.app.json: erweiter die tsconfig.base.json und konfiguriert den Kompiliervorgang der Haupanwendung.

	tsconfig.spec.json: spezifiziert wie die Unit-Ttest kompiliert werden sollen.

	tslint.json: Konfiguration für TS Lint tool für einheitlichen Codesil.

	enviroment folder: Konfigurationsdateien für Entwicklung / Produktion Umgebungen.

#######################################################################################################################################################################################
PIPEES
######################################################################################################################################################################################

PIPES werden genutzt, um Daten für die Anzeige zu transformieren. Hinter einer Pipe steckt eine Funktion, die den Eingabewert nach einer bestimmten Vorschrift verarbeitet und das
 tranformierte Ergebnis zurückgibt. Klasse implementiert export class RISAzonositoConverterPipe implements PipeTransform interface mit tramsform() Methode.

JSONPIPE: verwendet js Funktion JSON.stringify(); vor allem zum Debuggeil js Objekte mit Interpolation nicht direkt im Template angezeigt werden können.(Object.object gibt es aus)
Mit dieser Pipe wird der Inhalt eines Objekt im template angezeigt.
{{myobject | json}}

ASYNCPIPE: damit können wir Werte aus einem Observable oder Promise direkt im Template auflösen. schreiben wir das Observable direkt in ein Property
 der Klasse, sodass wir aus dem Template darauf zugreifen können. (im Normalfall wird haben wir keine Property von Observable type, sondern eine Property für dieDen Rest erledigt die
 erhaltene Werten.  Pipe für uns: Sie erstellt eine Subscription und liefert die empfangenen Werte direkt
 ins Template. Wird mehrmals  in der Template verwendet so wird erneuet ein Request gesendet ( wenn man nicht share() Operator verwendet)

 let books$: Observable<Book[]>;

 ngOnInit() {
	this.books$ = this.repo.getBooks();	// subscribe nicht notwendig
	}

 im Template: *ngIf="books$ | async as books; else loadingBooks"

EIGENE PIPES ENTWICKELN: Eine Pipe besteht im Wesentlichen aus einer Klasse mit nur einer Methode transform(). Diese Methode nimmt einen Wert value und optional eine beliebige
Anzahl Argumente entgegen und liefert den transformierten Wert zurück. Man sollte das Interface PipeTransform verwend. Soll die Pipe eine unbestimmte Zahl von Argumenten erhalten, ist es
allerdings unmöglich, die Methodensignatur genau anzugeben: Rest-Syntax -> transform(value: unknown, ...args: unknown[]): unknown


######################################################################################################################################################################################
Wir müssen die Applikation stets in allen benötigten Sprachen kompilieren. Soll die Anwendung z. B. zehn Sprachen »sprechen«, so müssen wir mit dem vorhandenen Tooling jeweils
zehn einzelne Anwendungen kompilieren und bereitstellen. Zur dynamischer Sprachwechsel in der Anwendung habe ich ngx-translate package verwendet.

######################################################################################################################################################################################
DIRECTIVES, CONTENT PROJECTION, VIEWCHILD, CONTENTCHILD, RENDERED2
#######################################################################################################################################################################################

CONTENT PROJECTION: zwischen den Selektor Elementen (Host Elementen) der Template können wir beliebige html Inhalt angeben. Dieses nennen wir "Content" die aber im normalfall nicht
 angezeigt wird. Wir können aber den Inhalt zugreifen und an eine child Komponente-Template übergeben -> content projection / tranclusion, indem wir die <ng-content> Platzhalter verwenden.
 (ez arra jo ha a child componensnek nem akarunk @Input talé adatot átadni)
 Wir können sogar mehrere Inhalte an mehreren beliebigen Stellen im child-template übergeben -> multi-slot Projection, zum Auswaehlen wird css selector verwendet.
 <ng-content select=".myClass"> Selector kann ein thml tag name, css class name sein. Jo ha nem akarunk property bindinggel adatot átadni a childnek, hanem komplett html-t.

NG-TEMPLATE: Platzhalter (placeholder), wird von Angular nicht gerendert. Kann aber mit Strukturdirektive referenziert und  angezeigt werden.
	Kann angezeigt werden:
		1.	Mit TemplateRef Variable:
			<ng-template #thenTemplateRefVariable>... using TemplateRef Variable
			<ng-template #elseTemplateRefVariable>...
			<div *ngIf="isValid; then thenTemplateRefVariable else elseTemplateRefVariable">
			oder.... in der Komponente: @ViewChild('sayHelloTemplate', { read: TemplateRef }) sayHelloTemplate:TemplateRef<any>;

		2.	<ng-template [ngIf]="selected">...<bg-template> ...
Hinter den kulissen Angular verwandelt alle Strukturdirektiven zu ng-template

https://morioh.com/p/fbef3198c6f0
Mit let keyword we declare a TEMPLATE INPUT VARIABLE, that can be referenced within the template. ngTemplate can use properties of its parent context.
It can also have its private context as we can pass values in the ngtemplate and use them inside it. This makes it a disconnected and standalone piece which can be reused many times.
 <ng-template  let-row="row" let-rowIndex="rowIndex" ami template input variablekat aztán használhatunk a ng-templaten belül
<ng-template ngFor let-elt [ngForOf]="array">
        <div style="color:green;">
            <h1>{{elt}} GeeksForGeeks</h1>
        </div>
    </ng-template>


STRUKTURDIREKTIVEN können Elemente aus dem DOM entfernen. Macht es nun einen Unterschied, ob wir ein Element mit CSS-Eigenschaften unsichtbar machen oder es tatsächlich aus dem DOM
entfernen? Beide Varianten sorgen dafür, dass ein Element im Browser nicht mehr sichtbar ist. Blenden wir Elemente jedoch lediglich aus, so sind sie tatsächlich noch vorhanden und
 werden verarbeitet. Es werden also auftretende Events behandelt, Bindings aktualisiert, und die Change Detection von Angular ist aktiv, um Änderungen in den Daten festzustellen.
 Bei größeren Datenmengen oder vielen Kindkomponenten und Abhängigkeiten kann das zu Einbußen in der Performance führen. Wird ein Element hingegen aus dem DOM entfernt, so ist es
 tatsächlich nicht vorhanden und muss auch nicht gerendert werden.

NG-CONTAINER: Dieses Element erzeugt kein DOM-Element, sondern wird direkt durch seinen Inhalt ersetzt. Der Container wird hauptsächlich verwendet, um darauf eine Direktive
 wie ngFor oder ngIf anzuwenden. Oder zur Verschachtelung von Direktiven: wenn wir ZB kein div element verwenden wollen. Strukturdirektive nicht auf einem html element verwenden.
	<ng-container *ngIf="isValid">
		<div *ngFor="let e of items">...</div>
	</ng-container>

VIEW ENCAPSULATION: Styles werden einer Komponente zugeordnet und wirken damit nur auf die Inhalte dieser Komponente (Shadow DOM). Jedes DOM-Element in einer Komponente erhält
automatisch ein zusätzliches Attribut mit einem eindeutigen Bezeichner, d.h. der selector Element kriegt vom Angular einAttribute, die wiederum in den Unterelementen auch
gesetzt wird. Die vom Entwickler festgelegten Styles werden abgeändert, sodass sie nur für dieses Attribut wirken.

// https://www.tektutorialshub.com/angular/understanding-viewchild-viewchildren-querylist-in-angular/
VIEWCHILD (Decorator): (View bezieht sich auf das Template) (Shadow DOM) wird verwendet, um einen Referenz etnweder auf eigenes DOM-Element des Komponents heraus zu bekommen,
        <div #myDiv...>
        @ViewChild("myDiv") headerRef: ElementRef;  // és nem id="myDiv" !!
       oder:
		zB. @ViewChild("header") headerRef: ElementRef; änderst sich der

	oder wenn der selector ein Typescript Klasse ist, was eigentlich ein Child-Komponent ist:
	// hier kriegen wir ein Referenz auf die child komponent klasse aus dem host komponent, und so können wir Werte auf dem properties der child komponent setzen.
		@ViewChild(BookListComponent) child: BookListComponent;

VC liefert das erste passende Element zurück.
 Wird auf Kompoenenten-Property verwendet, hat 2 Argumente: Selector (string, Typescript Type, wie Komponente Klassenname oder Function), Konfigurationsobjekt:
	static -> Es definiertiert, wann im Lebenszyklus der Komponente die Query ausgewertet wird.
				True: aufgelöst wenn der View inizialisiert ist.
			  False: aufgelöst beim jeder change detection , sollte verwendet werden wenn child renderiert dynamically.
    read   -> wenn selector definiert mehrere Elelemnte von
			  verschiedenen Typen, dann mit read property können wir einen auswaehlen.
Use cases:
	-	Wir bekommen einen Referenz in der Eltern-Komponente auf die Kind-Komponente (und können Methoden auf dem child-comp aufrufen):
		@ViewChild(ChildComponent, {static:true}) child: ChildComponent;

	-	Wir bekommen Zugriff auf ein HTML Element in der Template:
		  <p #para>Some text</p>
		   @ViewChild('para',{static:false}) para: ElementRef;

VIEWCHILDREN: liefert eine Liste von Elemente als QueryList zurück, wird immer nach change detection aufgelöst, wird immer von Angular aktualisiert. QueryList.changes Property ist
	ein Observable was emittiert ein Erreignis wenn Angular die Liste manipuliert. Weder VC noch VCS funktioniert wenn Child-Komponente mit Strukturdirektiven erstellt sind!!

TEMPLATE VARIABLE: mit diesen können wir Daten in einem Teil des Template in einem anderem Teil des Templates nutzen. Man deklariert Template Variable mit #.
mit tv können Folgenden referenziert werden:
	-	DOM Element
	-	Directive
	-	ElementRef
	- 	TemplateRef

ELEMENTREF: es ist ein Wrapper um die native DOM (HTML) Element, es hat nativeElement was ein Referenz ist auf das darunterstehende DOM Objekt. Um das DOM mit ElementRef zu
 manipulieren, wir setzten ein Referenz auf das DOM Element: verwenden ein TEMPLATE REFERENCE VARIABLE auf das Element (#VariableName), und dann in der komponente wir verwenden
 @ViewChild um das referenzierte Element zu referenzieren:

 <div #hello>Hello Angular</div>

 @('hello', { static: false }) divHello:
 ElementRef; Mit naviteElements  property können wird dann style/classes/prpoertys setzten.

RENDERER2: ermöglicht uns, die DOM Elemente zu manipulieren, ohne diese direkt zugreifen. Es ist ein Abstraktionslayer zwischen DOm und Komponent-Kode. Sollte anstetten von
 ElementRef verwenden, weil Angular snychronisiert das View und Komponent durch das Template, data binding, change detection, und beim Verwenden von ElementRef all diese werden
 ausgelassen. Renderer2 muss als Konstrukor-Property deklariert werden, und dann können wird damit Element erstellen, Styles/Classes/Propertys/Html Attribute zugeben/entfernen.

  const innerText = this.renderer.createText('book-list.caption');  // text justr created, not yet added to the DOM            
  this.renderer.appendChild(this.booklistheader.nativeElement, innerText);  // adding it to existing element

CONTENTCHILD: (Content bezieht sich auf das projected Content)  ein Referenz auf die Projected Content in dem DOM zu bekommen. (Projected Content ist ein html Inhalt,
	das eine Komponente vom parent component erhaelt. Um einen Referenz auf das projected COntent in dem Child-Kompoenent zu bekommen wir verwenden @ContentChild(selector) Dekorator
	auf ein Klasse-Property, dessen Argument ist ein template Variable von ElementRef Typ. Hat auch static und read  Optionen.

######################################################################################################################################################################################
KOMMUNIKATION ZWISCHEN KOMPONENTEN UND DATENAUSTAUSCH/ÜBERGABE
#######################################################################################################################################################################################


https://www.tektutorialshub.com/angular/angular-component-communication-sharing-data/

A. Komponente haben paretn-child Beziehung:
	Von Eltern zu Kind-Komponente:
		-  Property-binding -> Verwendung von @Input Dekorator.
		-  Lauschen auf Inpur Aenderungen: child kann mit onChanges() oder mit set methode auf dem input Property
		   benachrichtigt werden, wenn das @Input Wert aendert sich.

	Vom Kind zu Eltern:
		-  Parent lauscht auf Ereignisse vom Kind.   In child wir dekorieren mit @Output Dekorator ein Property, der ein Typ von EventEmitter<payload> ist.
			@Output() myevent: EventEmitter<Payload> = new EventEmitter();
			Dann im child wir lösen das Ereigniss aus: myevent.emit(this.payload);
			Parent fängt dieses Erigniss im template ein: ... (myevent)= "myeventHandler($event)"

		-	Verwendung von lokalen Variable (TemplateRef) um auf die Kind-Komponente zugreifen:
			<child #childTemplateRef></child> in der Parent-Komponente , in der Child_Komponente selector
			und mit Interpolation auf der Proerty der ChildKomponente zugreifen {{childTemplateRef.propertyInDerChildKomponente}} (mit change detection sogar)

		   'Parent interacts with child via local variable' ... child component hat ein function: methodOne() und wir wollen es im parent template verwenden:
			!! De ez csak a templaten belül műx, ha arra van szükség, hogy a parent component classból érjük el a child component metódusait/propertijeit akkor @ViewChild kell

			@Component({
			  selector: 'app-root',
			  template: `
					<h1>{{title}}!</h1>
					<p> current count is {{child.count}} </p>
					<child-component #child></child-component>`   -- Now you can use the local variable elsewhere in the template to refer to the child component methods and properties
					LOCAL VARIABLE
					<button (click)="child.increment()">Increment</button>
					<button (click)="child.decrement()">decrement</button>
			  styleUrls: ['./app.component.css']
			})
			export class AppComponent {
			  title = 'Parent interacts with child via local variable';
			}

		-	Mit @ViewChild bekommen wir ein Referenz aus  dem Parent-Komponent heraus auf die Child-Komponent und so haben wir Zugriff auf seine Properties.

B.	Es gibt keine Beziehung zwischen den komponenten:
	1.	mit Services in den Route Definitionen: Datenaustausch zwischen Komponeten, die zu gleichen route child angehören.
	2.	Mit Observable: erstellt man ein Service und ein Observable darin, das ein Ereignis wird emittiert sobald es zur Verfügung seht oder sich aendert. In der komponenten können
		wir dann daran abbonieren. https://www.tektutorialshub.com/angular/angular-component-communication-sharing-data/#listens-to-child-event

######################################################################################################################################################################################
BOOTSTRAPPING ANGULAR:
#######################################################################################################################################################################################

Angular takes the following steps to load our first view.

	1.	Loads Index.html
	2.	Loads Angular & Third-party libraries & Application, angular findet findet diese in dem package.json
	3.	Executes application entry point (main.ts), die genaue Stelle findetangular im angular.json
	4.	Load & execute Root Module (app.module.ts)
	5.	Executes the Root Component (app.component.ts)
	6.	Displayes the template (app.component.html)

	Wir bauen die Anwendung  entweder mit ng serve (speichert die kompilierte Anwendung nicht auf der Festplatte, sondern speichert es in der Memory und startet dann der Server)
	oder mit ng build. Der kompiler erstellt folgende script-Dateien:
		-	runtime.js: Webpack runtime files (module loader)
		-	polyfills.js: browser support für aeltere Browsers
		-	main.js: den Bootstrap-Prozess anzustossen und die Anwendung zu starten.
	Angular kommt mit dem Webpack bundler, der scannt die Anwendung für js Dateien und bündelt sie in js bunndles.

Wenn index.html ist geladen, dann core and 3party libraries sind ebenfalls geladen. Angular braucht ein Einstiegspunkt: main.ts (declariert im angular.json).
platformBrowserDynamic im main.ts ist ein Module, der bootstrap die Anwendung für desktop browser durch Laden der AppModule.ts, was danach die RootComponent ladet.

######################################################################################################################################################################################

######################################################################################################################################################################################

Dieses verursacht template parse error: 	<div *ngIf="selected" *ngFor="let item of items">{{item.name}}
										stattdessen: <ng-container *ngIf="selected"><div *ngFor="let item of items">{{item.name}}

######################################################################################################################################################################################
DIRECTIVES
#######################################################################################################################################################################################

DIREKTIVEN sind Klassen, die einem DOM-Element eine zusätzliche Logik zuordnen. Zur Verdrahtung besitzt jede Direktive einen Selektor, mit dem sie an konkrete DOM-Elemente gebunden
 wird, z. B. durch einen spezifischen Elementnamen oder ein Attribut eines Elements. Beinhaltet ein Template ein Element, das zu diesem Selektor passt, wird die Direktive angewendet
 und steuert das Verhalten des Elements. Host-Element ist Element, auf dem eine Direktive aktiv ist. Wir erweitern also mit Direktiven das Vokabular von HTML.

	ATTRIBUTDIREKTIVEN werden eingesetzt, um das Aussehen oder das Verhalten eines DOM-Elements zu verändern / steuern. Man nennt sie Attributdirektiven, weil die Verdrahtung
zwischen DOM-Element und dessen Direktiven/Komponentenklasse durch ein HTML-Attribut erfolgt, und nur auf das Element selbst auswirken.  z.B. [ngClass]

	STRUKTURDIREKTIVEN hingegen ändern die Struktur des DOM-Baums,indem sie Elemente hinzufügen oder entfernen. Die Metadaten werden als Objekt in den Decorator hineingegeben.
 https://www.tektutorialshub.com/angular/angular-ngonchanges-life-cycle-hook/_


ATTRIBUTDIREKTIVEN
Wenn wir an ein Attribut binden wollen, müssen wir den Attribut namen immer in eckigen Klammern notieren, denn das ist der Weg, Attributnamen mit CSS-Selektoren zu matchen.
	@Directive({
		selector: '[myDirective]'
	})

	in der Template, das binding die Direktive class an das DOM-Element (Host-Element):

	<div myDirective>Angular</div> ...Property-Schreibweise (statisch), nur für Übergabe von string literals
	<div [myDirective]>Lorem ipsum</div> ...Property-Schreibweise, für Übergabe von Ausdrücken
	<div *myDirective>Foobar</div> ... Strukturdirektive-Schreibweise, für Übergabe von Ausdrücken ...all dise 3 sind identisch

Wertübergabe von Host-Element in die Direktive, es ist das gleiche Property-Binding wie beim Kompoenenten (@Input).: (mint mikor a parent comp selector jabol property bindingel
értéket adunk át a child compnak.)

Über dem Host-Element können wir Werte in die Direktive/Komponentenklasse übergeben:
	<div myDirective="string literal">Angular</div> ...Attribut-Schreibweise, nur für Übergabe von string literals
	<div [myDirective]="Ausdruck">Lorem ipsum</div> ...Property-Schreibweise, für Übergabe von Ausdrücken
	<div *myDirective="Ausdruck">Foobar</div> ... Strukturdirektive-Schreibweise, für Übergabe von Ausdrücken ...all dise 3 sind identisch
Die Daten werden mit @Input in der Direktive ausgelsesen.(Wie beim Komponenten)

...oder, Werte übergeben mit belibigen Propertys:

	<div myDirective="adat" anotherProperty="adat" ...oder durch ein belibiges Property

Wertübergabe von der Direktive-Klasse in das host element. ( es ist die entgegengesetzte Richtung wie beim [mgClass] oder [ngStyle]),
Wir können aus der Direktive-Klasse auf das Host-Element zugreifen( ezért nevezzük HostBinding/Listener-nek)
Wir binden ein property zu dem host Element, wenn proprty aendert Hostbinding wird da host Element updaten:
	-	@HostBinding
	-	ElementRef.
	-	@HostListener (für Komponente auch !): HostListener('click') myClick(){ } is exactly the same as (click)="myClick()"
	Als Bezeichner für das Binding wird der Name der Eigenschaft/Property verwendet.
	Also hier setzten wir die Eigenschaft/Property des Host-Elements aus der Direktive hinaus.

// wenn wir bestimmte Attribute/Eigenschaften des host dom elements setzten wollen:
	@HostBinding() class = 'active';

	// Eigenschaft <div title="ezaz"... auf 'Mein Titel' setzen
	@HostBinding() get title() { return 'Mein Titel'; }

	// CSS-Klasse 'active' anwenden
	@HostBinding('class.active') isActive = true;

	// CSS-Eigenschaft 'color' auf 'red' setzen
	@HostBinding('style.color') get foo() { return 'red'; }
	Binding erlauben aber keine direkten Zugriff auf das DOM-Element. daür ist die ELementRef (durch konstrukto Propoerty Referenz auf dem Host-Element, mit @ViewChild)

Häufig verwendet man Attributdirektiven, um auf Ereignisse zu reagieren, die auf dem Host-Element auftreten. Diese Events lassen sich durch den Decorator @HostListener(mouseenter)
 abfangen, sodass wir in der Attributdirektive darauf reagieren können. Wir annotieren damit eine Methode.

STRUKTURDIREKTIVE: Strukturdirektiven sind immer dann sinnvoll, wenn Elemente in Abhängigkeit von bestimmten Faktoren ein- und ausgeblendet werden sollen.
Die Möglichkeiten sind sehr vielfältig: Denken Sie beispielsweise an Feature-Toggles, zeitliche Verzögerung oder Sichtbarkeit abhängig von Berechtigungen.
Strukturdirektiven werden immer mit dem Stern-Symbol (*) einge- Kurz- und Langformleitet.Ist dessen Wert wahr, wird das Element in den DOM-Baum eingefügt,
 andernfalls wird es entfernt. Die Syntax mit dem Stern *ngIf wird umgewandelt in ein <ng-template>, das die Attributdirektive [ngIf] trägt. In diesem
Template-Element befindet sich das eigentliche HTML-Element, auf dem vorher die Strukturdirektive zu finden war.

	<!-- Kurzform -->
	<p *ngIf="myValue">Ein Text</p>

	<!-- Langform -->
	<ng-template [ngIf]="myValue">
		<p>Ein Text</p>
	</ng-template>

	Jedes Element besitzt ein Container View <ng-template> darauf Zugriff Mit ViewContainerRef, worin der Template eingebettet ist, darauf Zugriff mit TemplateRef. (<p>)

ATTRIBUTE DIRECTIVE:

STYLE
https://angular.io/guide/class-binding	//ez nagyon jó példa és rövid
Style-Attibute setzen:

[style.color]="getMyColor()": setzt man nur ein einziger Property mit standard property binding.
[style.max-width.px]="120": glecihe vie oben nur mit unit auch spezifiziert.
[ngStyle]="map": setzt man mehrere  Style-Properties gleichzeitig, Direktive

CLASS
Class-Attribute setzen:
 [class]="myRedClass": dieses setzt ein einziger Class und überschreibt dabei alle existierende class Definitionen
 [class.bg-warning]="editing": setzt nur der angegebene class property nachdem der Ausdruck ausgewertet wurde. ( wenn rRückgabewert false ist dann wird style überhaupt nicht angewendet)
 [ngClass]="map": setzt man mehrere CSS-Klassen mit einem map Objekt, Direktive

######################################################################################################################################################################################
DEPENDENCY INJECTION
#######################################################################################################################################################################################

https://www.tektutorialshub.com/angular/angular-dependency-injection/
https://www.tektutorialshub.com/angular/how-dependency-injection-resolution-works-in-angular/

Angular DI Framework:

	CONSUMER: der. die Abhängigkeit deklariert.

	DEPENDENCY: das Service, das wir als Abhängigkeit verwenden.

	PROVIDER: Bauanleitung nennt man Provider.mit diesen registrieren wir Dependencies (Klasse, Funktion, Werte), Providers sind durch TOKEN registriert, es beschreibt
			wie ein Object für den Token erstellt wird.	(Bauplan , Token = Identifizierung eines Bauplans, dieses ist der Kontruktorparameter)

			Damit DI über Konstrukor funktioniert,  muss angular wissen welche Klassen zur Verfügung stehen. Es soll ein Bauanletiung geben, wonach DI ein Instanz erzeugt.

			Configuring Providers mit Konfigurationsobjekte {provide, useClass/useValue}:

			providers: in diesem Metadata definirern wir Provider Konfigurationsobjekte mit dem Schema:
				- provide(= Token: string, class injectiontoken) Also Identifizierung eines Zb: KlassenDependency kann durch eine beliebieges String Name, oder durch die
					Klassenname auch erfolgen.
				- provider: class, value, factory.

                KURZFORM:
				[ProductService] ist Kurzform für: providers in component Annotaion Metadata provider Properrty: [{provide: 'productService", useClass: ProductService}]
				Und im constructor: constructor(private productService: ProductService)

				Provider Objekt (in array):[{
					provide: ProductService, 	// DI Token = Injection token, identifiesa dependency, can by type/string, Injection token
								- type: MyServiceKlasse
								- string Token:
										{provide:'PRODUCT_SERVICE', useClass: ProductService },
										{provide:'USE_FAKE', useValue: true },
										{provide:'APIURL', useValue: 'http://SomeEndPoint.com/api' },
									Verwendung:  constructor(@Inject('PRODUCTSERVICE') private prdService:ProductService
								- InjectionToken: zum Vermeiden dass 2 Entwickler die gleiche Token verwendet.
									useClass: ProductService }
					provider:
							-	Class Provider : useClass = wenn Abhängigkeit ein Klasse ist.
							-	Value Provider: useValue = wenn es ein einfacher Wert ist.
								zB: providers :[ {provide:'USE_FAKE', useValue: true}] ->  constructor(  @Inject('USE_FAKE') public useFake: string
								sogar Funktion kann auch angegeben werden.
							-	Factory Provider: useFactory -> den Rückgabewert einer Funktion, zB. anhängig von einem Wert sollen wir entweder servce1 oder srvice2 Verwenden.
							-	Aliased Class Provider: useExisting -> Verwendung von einen alten Provider anstelle eines neuen.
					})

			injector: hat das provider, instanziert eine Abhängigkeit und injiziert sie in das Service/Komponent.
			  Injector verwendet das Token, den wir als Konstruktor-Parameter deklarieren, um ein Provider zu  indentifizieren, was eigentlich eine Verkopplung von Token zu einer
			  Klassbaulplan/String ist. Das Injector muss aber wissen, welche Klasse instanziert werden muss für diese Abhängigkeit.


https://www.tektutorialshub.com/angular/how-dependency-injection-resolution-works-in-angular/
	Auflösung der Abhängigkeit: (= der Instanz einer Abhängigkeit ist auf dem level wo das Provider registriert ist = das ist der scope der Service, innerhalb ser Komponent/Module
			Baumes)
			  Injector sucht mit diesem Token (=Konstruktor-Parameter) nach einem Provider in der provider array (wir sprechen hier über Provider, weil wir registrieren
			  dependecies mit providers  in der module/directive/component). Findet ein Provider, dann schauet es nach ob ein Instanz der Abhängigkeit schon vorhanden ist.
			  Wenn existiert dann injiziert es diesen Instanz in das  Komponent, wenn noch nicht dann erstellt eines und injiziert es danach.

			Wenn kein passender Provider gefunden wird, dann wird die Suche in den Parent Injectors weitergehen. wird dann das Provider gefunden, dann wird dem Provider dem
			ursprünglichen Injector gegeben . Wird kein Provider gefunden, dann geht die Suche in der ModuleBaum weiter (erst in seinem eigenem Module).
			Wird überhaupt kein Provider gefunden, so wird ein	"No provider for service" error geworfen. Markieren wir die Konstruktor-Parameter mit @Optional()
			dann wird kein error geworfen sondern bekommt man null (und können wir mit ? schergehen). Injectoren werden zerstört, wenn Angular Module/Directive etc. entfernt.

			Wenn zB ich 2 Kompoenente habe, die die gleiche Abhängigkeit teilen sollte , dann könnte ich es auf parent Kompoenent level registrieren.

Services sind singletons nur innerhalb der scope wo sie registriert sind.

Tree-shakable providers:

"Singleton" nennen wir ein Service, wenn es nur ein einziges Instanz in der ganzen app gibt. Wir folgendermaßen erstellt:
	"providedIn: root": Verwendung von "root" Option in der providedIn Property: dieses mach singleton unabhängig von eagerly/lazy loaded modules. preferred way
	-	Deklarieren in der Provider array des @NgModule, ist es root oder eagerly loaded module, dann wird es ein Anwendung-Singleton.

	!!!!!
	Ist es jedoch ein lazy loaded module, dann ist der Service nur innerhalb dieses Module verfügbar, nicht aber außerhalb.
	(richtigen app-wide Singleton deklarieren wir in Modules nicht in Elementen(Komponente etc))

	"providedIn: any":  lazy modules haben ihre eigene Insatnz; gäben wir "root" an , würde das heißen,
	das lazy loaded modules auch würden mit den gleichen service Instanz arbeiten-> wir wollen aber ein neues Instanz für je lazy module haben; das ermöglicht "any".
	(ist es ein eagerly module, dann hat es keinen Effekt, weil sie immer den gleichen Instanz mit dem root module teilen)
	providedIn=platfrom . gleiche Insatnz wird in allen Applikation verteilt.

	Ansonsten wir können alle schon in den Modulen verwendeten Einstellungen im TS providers verwenden; zb: wir wollen ein service in DepinjModule declarieren:
		@Injectable({}
				providedIn: DepinjModule,
				useClass: DepinjModule // hier unnötig, weitere Optionen useExisting, useValue
			})

Angular erstellt jeweils einen Instanz von Injector und dazu jeweils ein Provider für alle Componente/Directive, rootModule,  für alle lazy loaded Modules.
Wenn providers Metadata array is empty damm Angular erstelt ein einen leeren Injector, Injectors werden zerstört wenn Komponent wird zertört.
Aber nicht für eagerly loaded Module, sie teilen die Injector mit dem  des rootModules . Angular erstellt damit ein Baum von Injector als parent-child Beziehung.
Die Dependencies registrieren wir mit den Providers in der providers: [] metadata des Injectors.

Angular kreiert 2 Injector_Baume: ModuleInjector Baum und Element Injector Baum( für Komponente, Direktive etc.)
Wenn die Anwendung startet, Angular ladet das root Module und erstellt ein RootModule Injector dafür und macht es ein Teil des ModuleInjector Baumes. Root module ladet die
AppComponent, die ihr eigenes Injector bekommt. Dieses wird das root des ElementInjector Baumes. Alle andere Komponente gehören unter diese root component an, mit all ihren eigenen
child komponenten. Dabei erstellt Angular jeweils ein Injector für diue jeweilige Komponente/Directive etc, den Baumsrtruktur des Komponenten nachahmned. Alle Abhängigkeiten werden mit
Providers registriert; jeder injector hat ein Provider (= providers meatdata in den @NgModule, @Component, @ Directive).

Wo man die Abhängigkeit registriert, bestimmt das scope derer. zB:
- Abhängigkeit registriert mit dem RootModule ist angehängt an das root provider (=provider des root modules, verfügbar überall). Abhängigkeit registriert in einem feature
Module ist verfügbar in disem Module und in den Kindermodulen.
- Abhängigkeit registriert mit der Kompoenente ist angehängt an das Komponent provider und ist verfügbar für diese Komponente , plus ihre child-Komponente.

Auflösung der Abhaengigkeiten einer Komponent:
Angular versucht den Instanz der Abhängigkeit erst der Injector der jeweiligen komponente finden. Wenn es nicht findet, dann geht es eine level oben und sucht den Instanz
in der Injector der Eltern-Komponente. Findet es nicht einmal in der Rootkomponent's Injector, dann wechselt es auf das Modulinjector Hierarchie und versucht es dort zu finden.

@Self() Dekorator instruirt den Angular, dass es nur in der Lokalinjector sucht. @SkipSelf instruiert um in der Eltern oder oberhalb zu suchen. Diese sind
Konstruktor-Parameter Dekoratoren.

@SkipSelf: Consumer deklariert eine Abhängigkeit auf eigener Ebene, wir sollen aber anstelle von diesem die Parents Provider verwenden.

@Optional: wird kein Exception geworfen wennn kein Provider gefunden wird, aber das Kompoenent soll prüfen, ob es null ist.

Wenn ein Komponent hat providers metadata: [mySerivce], dann jeder Instanz der Komponent hat sein eigenes Service Instanz. (Service instanz nur mit @Injectable(empty) )

######################################################################################################################################################################################
ANGULAR CLI
#######################################################################################################################################################################################

Angular CLI: aufgerufen mit "ng" keyword, installiert mit npm install -g @angular/cli@latest
Wenn man diese Kommandos im root Verzeichnis durchführt.

generate (g) Kommando:
-	ng g component Hello: macht folgendes:
		-	Erstellt Hello Mappe unter dem src/app.
		-	Erstellt HelloÍComponent mit css, spec und template Dateien unter der Hello Verzeichnis.
		-	Importiert HelloComponent in das root Module und gibt es zu "declaration" array
		-	CSS selector verwendet die Format app-<name>. i.e app-hello
	Mit den Optionen:
			--flat:  Hello Verzeichnis wird nicht erstellt, nur unter dem src/app
			--flat idebe/hello: erstellt Komponent unter dem idebe Verzeichnis
			--prefix=myapp hello: css selector wird myapp-hello anstatt app-hello
			--selector=igen --force hello: gibt selector Name nur "igen" ohne prefix
			--module=book: registriert Komponent in dem book Module(ng g component --module=book --flat idebe/Hello -> erstellt ein K. in dem idebe Verzeichnis und
																	registriert es in dem book Module)
		ng g module	hello --routing=true: generiert Hello Module und dazu ein noch das hello-routing.module.ts und registriert es mit forChild(routes)

######################################################################################################################################################################################

Authentication:
JWT Authentication: digital signed JSON payload, das username und Ablaufdatum enthält. Dieser Typ von Token ist das Bearer Token.
Wenn der User einloggt und und der Server sendet der Token zurück, dann wird dieser Token in einem global-scoped Service gespeichert und bei jeden Request in dem http header:
 Authorization: Bearer<TokenString> verschickt. Das zu verwirklichen wurde ein Interceptor service implementiert.

######################################################################################################################################################################################

ViewProvider

https://debugmode.net/2020/06/24/when-to-use-viewproviders-in-angular-simplified/
ähnlich dem provider metadata Property, aber bei disem werden die Abhängigkeiten nur für das View zur Verfügung gestellt, nicht aber für die projizirte content.
The viewProviders defines the set of injectable objects that are visible to its view, DOM children. They are not visible to the content children.

######################################################################################################################################################################################

Interceptorok felhasználási területei:
https://medium.com/angular-in-depth/top-10-ways-to-use-interceptors-in-angular-db450f8a62d6

implements HttpInterceptor -> intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>

######################################################################################################################################################################################
https://www.tektutorialshub.com/angular/valuechanges-in-angular-forms/

DOM event -> Observable
Angular stellt RxJS  FormEvent Methode zu Verfügung, um ein Observable aus DOM Errignisse zu machen. Zb: Wir haben ein FormControll input und wir wollen auf keyup Erreignisse abbonieren,
(so server calls starten) damit wir ein autocomplete implementieren.

fromEvent(this.idInput.nativeElement,'keyup').subscribe(res => console.log(res));
const clicks = fromEvent(document, 'click');    clicks.subscribe...

######################################################################################################################################################################################

ng add @ngrx/store

jó egyszerű bevezető példa
https://ngrx.io/guide/store

https://dzone.com/articles/angular-app-state-management-with-ngrx

- kérdés: ngrx el menedzseljük a form datat is?
- az inputoutputot át lehetne jol irni reduxra
Ausgangssituation: Wir haben ein form und ein table Kompoenent, wenn ein neuer Product in den form Kompoenent eingetragen wird, dann wird der neue Produtkt in dem  Tabellenkomponent
angezeigt.
	Lösung ohne NgRX: beide Komponente haben ein gemeinsames Elternkomponent, wodurch sie miteinander kommunizieren. Wird ein Product eingetragen, dann wird in der form Komp.
	ein custom Erreignis mit dem Product payload ausgelöst (@Output) -> dieser Erreignis wird vom Parent Komponent empfangen und die products array damit aktualisiert. Table component
	(in dem View) enthält ein @Input property products, die im Template angezeigt ist; dieses Property wird mit property binding immer aktualisiert wenn das Product array vom
	parent aktualisiert ist.
	Table kann selected Product (mit Klikk auf der Tabellenreihe) ebenfalls als ein Erreignis-Payload an das Form Kompoenente schicken, worauf - wie oben -durch event binding
	ein Handler Methode aufgerufen wird, um die form Felder zu populieren.

NgRX
Ursprünglich jede Komponente hatte ihren eigenen Zustand und bildete eine abgeschottete Einheit zu den anderen Komponenten. Im NgRX Die Komponenten sollen dazu ihre bisherige Kontrolle
 über die Daten und die Koordination der Prozesse an eine zentrale Stelle abgeben. Die Aufgabe der Komponenten ist es dann nur noch, Daten für die Anzeige zu lesen,
 neue Daten zu erfassen und Events an die zentrale Stelle zu senden. zentrale Zustandsverwaltung (engl. State Management).

 REDUX: ein Architektusmuster;
 NgRX, Reactive Extension for Angular: Imlementierung von Redux Muster; Anwendunszustand verwalten und Prozesse verwalten.

 Der zentrale Bestandteil der Architektur ist ein Store, in dem der gesamte Anwendungszustand als eine einzige große verschachtelte Datenstruktur hinterlegt ist Der Store ist
 die Single Source of Truth für die Anwendung und enthält alle Zustände: vom Server heruntergeladene Daten, gesetzte Einstellungen, die aktuell geladene Route oder Infos
zum angemeldeten Nutzer – alles, was sich zur Laufzeit in der Anwendung verändert und den Zustand beschreibt.

Store: enthält die application state / Zustand
Action: Erreignis, ausgelöst in dem Kompoenent / service, das den Applicationszustand mit seinem Payload ändert. Ein Acion ist zB addCustomer, deleteCustomer, getAllCustomers
Reducer: alle Zustandsänderungen passieren hier, es reagiert auf dem Action und je nach dem Actiontype kreiert ein neues immutablen state und gibt es dem Strore zurück.
Selector: eine Funktion, um bestimmten Teil des State von dem Strore zu erhalten.

Jedes Feature Module soll ein eigenes ngrx feature haben (= mit eigenen Satz an Actions, Reducerns, Effects). Mit ng g feature können wir ngrx für ein bestehendes Feature-Modules
aufsetzen. ng g feature inputOutput/store/inputoutput --module inputOutput/shared/inputOutput --api --defaults

1.	StoreModule soll im AppModule importiert werden und hier konfigurieren wir den DevTool auch:
		StoreModule.forRoot({}, {}),
		StoreDevtoolsModule.instrument(
		{ maxAge: 25, logOnly: environment.production }
		)

2.	NgRX einrichten in dem jeweiligen Feature Module, hier definieren wir die Struktur des globalen State-Objekts:

	StoreModule.forRoot(fromBook.bookFeatureKey (= unter diesen Namen wird die Zustände dieses Feature im globalen State-Objekt festgelegt, fromBook.reducer
	(=dieser Reducer ist verantwortlich für den State-Teil) ); ->
	der globale State-Objekt wird durch forRoot also erweitert und die reducer wird integriert in die Anwendung.

3.	Definieren der inputoutput feature-state für das Feature inputoutpt, als Interface , die festlegt welche Zustänfe und Daten wir speichern wollen.
	Variable initialState.

4.	Action: für die Kommunikation mit dem Store. Es ist ein "nachricht" Objekt mit Properties type und payload. NgRX stellt createAction Funtion zur  Verfügung:
	1 Argument für Name der Action,
	2. Arg: Payload. Ein möglicher Action-Onjekt Aufbau:
		{
			type: '[Inputoutput] Load Inputoutputs Success',
			data: Book[]
		}

5.	Um mit dem Store zu kommunizieren und Zustandsänderungen anzustoßen, müssen die Actions von den Komponenten in den Store gesendet werden. Der Store verfügt über eine Methode
	dispatch(), mit der wir eine Action in den Store dispatchen können. Aktionen werden von kompoenenten ausgelöst.

6.	Mit reducer verändern wir den State, es ist eine Funktion die den aktuellen Zustand und die entreffende Aktion als Arg  bekommt. Es berechnet den neuen Zustand und
	liefert zurück. Für jede Fallunterscheidung existiert ein Block, der in ein on() gekapselt ist.


 ######################################################################################################################################################################################

 Object type in TS
 https://mariusschulz.com/blog/the-object-type-in-typescript

 TS empty type:
  It describes an object that has no members on its own. TypeScript issues a compile-time error when you try to access arbitrary properties on such an objec
 let valamu = {};
 ez lehet bármi, pl egy array valami[11]=true;
 pl: auditlog-modal.component.html

  #####################################################################################################################################################################################
  https://christianlydemann.com/the-complete-guide-to-angular-performance-tuning/


https://www.javatpoint.com/data-binding-in-angular-8
Data binding is the core concept of Angular 8 and used to define the communication between a component and the DOM.
ONE-WAY DATA BINDING:
	One way databinding is a simple one way communication where HTML template is changed when we make changes in TypeScript code.
	In one-way databinding, the value of the Model is used in the View (HTML page) but you can't update Model from the View.
	Angular Interpolation / String Interpolation, Property Binding, and Event Binding are the example of one-way databinding.


PROPERTY BINDING [property]="expression", (target property -- component property)(wir binden den Property von einem DOM Element/Component Property zu einem statischen Wert/Component/Directive Property.
	Mit property binding wir setzten den PropertyWert eines DOM elements / oder den property eines Components mit dem Wert eines Komponentenpropertys
	(parent-child Kommunikation, dann im child component wir haben mit @Input() Zugriff auf das Property).
	Alos: Wert ist entweder statisch oder kommt von einem Komponenten property in das target Property, das entweder ein DOM element oder ein child Komponent Property ist.
	Der Wert kann statisch sein ( in disesm Fall verwenden wir keinen []), oder kann ein template expression sein, dessen Wert dinamisch ausgewertet wird (Verwendung von [])
	Es ist ein einwegiger Kommunikation, geht nur in eine Richtung. Wenn der Wert eines template expression geaendert wird, dann wird es vom change detection detektiert und
	der Property's Wert geupdated!

ATTRIBUTE BINDING: aehnlich wie property binding, aber wir prefixen das zu schreibende attribute mit "attr" prefix:
		<td [att.colspan]="myexpression"..>

https://angular.io/guide/property-binding

EVENT BINDING: damit können wir auf Ereighnisse auf einem DOM element lauschen. (event)="myHandler($event)" Event abonnieren (target event, myHandlet= template statement).
			Wir binden entweder zu DOM Elements eigener Event oder zu einem von uns definierten (@Outpt) event.

TWO-WAY BINDING: zweiseitige kommunikation zwischen model und view. Eigenschaften setzen und Ereignisse verarbeiten, vor allem verwendet für Template-Driven Forms.
		<input [(ngModel)]="fullName"/>
		{{fullName}}
		public fullName = 'pista'; // hier wird gleich angezeigt von Buchstabe zu Buchstabe wenn man in input filed schreibt.
	és a háttérben ez igy működik:   https://blog.thoughtram.io/angular/2016/10/13/two-way-data-binding-in-angular-2.html

ATTRIBUTDIREKTIVE [ngClass]="expression" Eigenschaften/Verhalten eines DOM-Elements verändern
INTERPOLATION {{ expression }} Daten im Template anzeigen
STRUKTURDIREKTIVE *ngIf="expression" DOM-Baum manipulieren, indem Elemente hinzugefügt oder entfernt werden
ELEMENTREFERENZ #myId Direktzugri auf DOM-Elemente oder ihre Direktiven
PIPE expr | myPipe | otherPipe Daten im Template transformieren

#####################################################################################################################################################################################
PERFORMANCE TUNING:
#######################################################################################################################################################################################

  Data binding: string interpolation, property binding, event binding, attribute binding, class and style binding, 2-way binding.
  Nach jedem DOM event das change detection leauft ab und prüft Aenderungen in den Werten für data bindings und rerenderiert das ganze Kompoenent.


  Ausgangssituation:
	By default change detection compoenente werden jedesmal neugerendert, wenn ein asynchron Erreignis passiert: click event, HttpRequest wird versendet etc, weil dabei
	change detection jedesmal ablaeuft.
	button click -> change detection lauft ab -> Kompoenent wird neu gerendert



	Lamgsamer Applikation kann auf folgende zurückgeführt werden:
		1	Improving change detection.
        2.  using pipes anstelle von string interpolation
		2	Überarbeiten page loading
		3	UX design Überarbeiten
		4.	trackBy for ngFor
		5.  improving page load: lazy loading

  1 A. https://angular.io/guide/pipes
		https://christianlydemann.com/the-complete-guide-to-angular-performance-tuning/

		wenn das data binding eine templae expression, d.h. eine Methode ist:
		Template expression Methode werden jedesmal neuausgeführt wenn das Komponent neugerendert wird, also wenn mit dem komponent oder mit dem child kompoenenten interagiert wird
		(button click etc, input field events etc.)
		Lösung: Implementieren von pure Pipes (by default alle pipes sind pure) anstatt Verwendung von Methoden, da pure Pipes transform Methode wird nur dann aufgerufen,
		wenn das Input (reference if it is a object) oder primitive types value geaendert wird (change detection prüft beim Objekten nur die properties die im template verwendet
		weren: wenn man mit {{log.username | printusername}} hat und man log.changeDate aendert dann printusername pipe wird nicht neuberechnet)
		und es wird nur einmal aufgerufen, wogegen unpure mehrmals.
		Technisch gesehen, wir überlagern die zeitaufwendige Logic in das Pipe, wo es aber viel seltener durchgeführt wird. Damit kann man vermeiden,
		dass in template expression Methode Dutzentmal vergebens aufgerufen wird.
		zB. Wenn man auf ein button click und pure pipe nicht betroffen ist, dann wird es überhaupt nicht durchgeführt, wogegen bei not pure pipe wird es mehrmals neuberechnet.

	  1. A. A. : weiterer Optimisierungsmöglichkeit ist die Chaching von Werten Pipes, so es ist nicht nötig neuzuberechnen wenn wird es schon mit dem gleichen Wert in der
				Vergangenheit berechnet haben.

 2.		ngFor="let user of users": wenn a user geaendert , entfernt oder hizugefügt wird Angular wird alle DOM nodes für die users list nerenderieren. Wenn wird wollen, dass
		Angular nur das betroffene Element DOM neurenderiert, dann müssen wir irgendwie Angular zeigen, welchee Element betroffen ist:
		trackBy directive, womit wir identifiziren unique elements in dem array, so kann Angular herausfinden welche DOM nodes in der List
		zu aendern sind.

		class User {
		  id: number;
		  name: string;
		  ...
		}
		function userTrackBy(index, user) {	return user.id;}

	3.  OnPush: @Component({
                changeDetection: ChangeDetectionStrategy.OnPush
              })
    https://blog.angular-university.io/onpush-change-detection-how-it-works/

4 ways to listen to DOM venets in Angular:
    1.  https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-1-event-binding-3ec7e9f51a1d
    2.  https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-2-hostlistener-1b66d45b3e3d
    3.  https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-3-renderer2-listen-14c6fe052b59
    4.  Using RxJS .fromEvent() operator that turns events into observable sequences
#####################################################################################################################################################################################
#####################################################################################################################################################################################
mapping outside the pipe operator:

 this.defaultService.getAllKonnektors().subscribe((konnektors) => {
      innerkonnektors = konnektors;
      mapKonnektors= innerkonnektors.map((dto) => {
             // let mappedKonnektor: KonnektorMapperDTO = {hostNameAndSerial: "www"};
              return {...dto, hostNameAndSerial: `${dto.hostName} - ${dto.serialNumber}`};
      });
      console.log('------ ' + mapKonnektors[0].hostNameAndSerial + ", :" + mapKonnektors[0].hostName);
    });

mapping inside pipe operator:
  this.defaultService.getAllKonnektors()
      .pipe(
        map( (konnektorArray) =>
          konnektorArray.map(b => b)    // itt még csak önmagára mappeljük vissza !! :)
        )
      )
      .subscribe( (konnektorsMapped) => {console.log('------ ' + konnektorsMapped[0].hostName);});
  }

//átmappelve
 this.defaultService.getAllKonnektors()
      .pipe(
        map( (konnektorArray) =>
          konnektorArray.map(konn => ({  // itt már kell a ( és a { !!!
            ...konn,
            hostNameAndSerial: `${konn.hostName} - ${konn.serialNumber}`,
            mappedDate: new Date().toISOString()
          }))
        )
      )
      .subscribe( (konnektorsMapped) => {
        console.log('------ ' + konnektorsMapped[0].hostNameAndSerial + ", :" + konnektorsMapped[0].hostName + ", mappedDate: " + konnektorsMapped[0].mappedDate);
      });
  }
interface KonnektorMapperDTO extends KonnektorDTO {
  hostNameAndSerial: string;
  mappedDate: Date
}



